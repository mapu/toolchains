//===-- MSPUISelDAGToDAG.cpp - A dag to dag inst selector for MSPU ------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the MSPU target.
//
//===----------------------------------------------------------------------===//

#include "MSPUISelLowering.h"
#include "MSPUTargetMachine.h"
#include "MCTargetDesc/MSPUMCTargetDesc.h"
#include "MSPUMachineFunctionInfo.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===--------------------------------------------------------------------===//
/// MSPUDAGToDAGISel - MSPU specific code to select MSPU machine
/// instructions for SelectionDAG operations.
namespace
{
	class MSPUDAGToDAGISel: public SelectionDAGISel
	{
		private:
			/// Subtarget - Keep a pointer to the MSPU Subtarget around so that we can
			/// make the right decision when generating code for different targets.
			const MSPUSubtarget &Subtarget;
			MSPUTargetMachine& TM;
		public:
			explicit
			MSPUDAGToDAGISel(MSPUTargetMachine &tm)
						: SelectionDAGISel(tm), Subtarget(tm.getSubtarget<MSPUSubtarget>()), TM(tm)
			{
			}

			SDNode *
			Select(SDNode *N);

			/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
			/// inline asm expressions.
			virtual bool
			SelectInlineAsmMemoryOperand(const SDValue &Op, char ConstraintCode, std::vector<SDValue> &OutOps);

			// Complex Pattern Selectors.
			bool
			SelectAddrJImm(SDValue Addr, SDValue &Base, SDValue &Offset)
			{
			  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
			      Addr.getOpcode() == ISD::TargetGlobalAddress)
			    return false;  // direct calls.

			  // note: llvm use OR instead of ADD to set alignment when lowering memory access
			  // via frame-index for i64.
			  // if dag is "base + offset"
			  if (Addr.getOpcode() == ISD::ADD || Addr.getOpcode() == ISD::OR) {
			    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
			    if (CN) {
			      Offset = CurDAG->getTargetConstant(CN->getSExtValue(), getTargetLowering()->getPointerTy());

			      FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0));
            if(FIN) {
              // Constant offset from frame ref.
              // [frame-index   +   offset]
              Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), getTargetLowering()->getPointerTy());
            }
            else {
              Base = Addr.getOperand(0);
            }

            return true;
			    }
			  }

			  // if we only get frame index
				FrameIndexSDNode * FI = dyn_cast<FrameIndexSDNode>(Addr);
				if(FI) {
					Base = CurDAG->getTargetFrameIndex(FI->getIndex(), getTargetLowering()->getPointerTy());
					Offset = CurDAG->getTargetConstant(0, getTargetLowering()->getPointerTy());
					return true;
				}

				// otherwise
        Base = Addr;
        Offset = CurDAG->getTargetConstant(0, getTargetLowering()->getPointerTy());
        return true;
			}

			bool
			SelectAddrJJ(SDValue Addr, SDValue &Val1, SDValue &Val2)
			{
				if(Addr.getOpcode() == ISD::ADD) {
					ConstantSDNode * CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
					if(CN)
						if(isInt<13>(CN->getSExtValue()))
							return false;    // Let the reg+imm pattern catch this!

					Val1 = Addr.getOperand(0);
					Val2 = Addr.getOperand(1);
					return true;
				}

				return false;
			}

			virtual const char *
			getPassName() const
			{
				return "MSPU DAG->DAG Pattern Instruction Selection";
			}

			// Include the pieces autogenerated from the target description.
			#include "MSPUGenDAGISel.inc"

		private:

      // this function match a unique frame index
			/*SDNode*
      getFrameIndex(SDNode *N)
      {
			  FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N);
			  assert(FIN);
			  unsigned FrameIndex = FIN->getIndex();

        const MSPUFrameLowering *TFL =
         static_cast<const MSPUFrameLowering*>(TM.getFrameLowering());
			  unsigned offset = TFL->getFrameIndexOffset(*MF, FrameIndex);

			  DebugLoc dl = N->getDebugLoc();
			  SDValue offsetVal = CurDAG->getTargetConstant(offset, MVT::i32);
			  SDNode *NJ31 = CurDAG->getMachineNode(MSPUInst::AssignPtr, dl, MVT::i32, offsetVal);
			  SDValue op(NJ31,0);

			  SDValue FP = CurDAG->getRegister(MSPUReg::J28, MVT::i32);
			  SDNode *N1 = CurDAG->getMachineNode(MSPUInst::PtrAdd, dl, MVT::i32, FP, op);
        return CurDAG->SelectNodeTo(N1, MSPUInst::PtrAdd, MVT::i32, FP, op);
      }*/

			SDNode*
			getGlobalBaseReg()
			{
				/// getGlobalBaseReg() is defined in MSPUInstrInfo class.
				unsigned GlobalBaseReg =
				  MF->getInfo<MSPUMachineFunctionInfo>()->getGlobalBaseReg();
				/// TLI: TargetLowering
				return CurDAG->getRegister(GlobalBaseReg, getTargetLowering()->getPointerTy()).getNode();
			}
	};
} // end anonymous namespace
#include <iostream>
SDNode *MSPUDAGToDAGISel::Select(SDNode *N) {
  if (N->isMachineOpcode())
    return NULL; // Already selected.

  int Opcode;
  switch (N->getOpcode()) {
  default:
    break;

  case MSPU_ISD::GLOBAL_BASE_REG:
    return getGlobalBaseReg();

  case ISD::INTRINSIC_VOID:
  case ISD::INTRINSIC_W_CHAIN: {
    unsigned IntNo = cast<ConstantSDNode>(N->getOperand(1))->getZExtValue();
    switch (IntNo) {
    default:
      break;

    case Intrinsic::mspu_callm:
    case Intrinsic::mspu_callmb:
      // DAG fix-up for CallM imm
      // The default DAG for intrinsic CallM is as follow:
      // (int_mspu_callm (XferAddr tglobaladdr))
      // which has to be change into:
      // (int_mspu_callm tglobaladdr)
      Opcode = IntNo == Intrinsic::mspu_callm ?
                   MSPUInst::__CallM : MSPUInst::__CallMB;
      if (N->getNumOperands() == 3
          && N->getOperand(2).getNode()->getOpcode() == MSPU_ISD::XferAddr) {
        SDNode *Xfer = N->getOperand(2).getNode();
        if (isa<GlobalAddressSDNode>(Xfer->getOperand(0).getNode())) {
          GlobalAddressSDNode *OldCallMAddr = cast<GlobalAddressSDNode>(
              Xfer->getOperand(0).getNode());
          SDValue CallMAddr = CurDAG->getGlobalAddress(
              OldCallMAddr->getGlobal(), SDLoc(OldCallMAddr),
              OldCallMAddr->getValueType(0), OldCallMAddr->getOffset(), true,
              OldCallMAddr->getTargetFlags());
          SDValue Chain = N->getOperand(0);
          SDValue Ops[] = { CallMAddr, Chain };
          return CurDAG->getMachineNode(Opcode, SDLoc(N), N->getValueType(0),
                                        Ops);
        }
      }
      break;

    case Intrinsic::mspu_loop:
      if (N->getNumOperands() == 4 &&
          N->getOperand(2).getNode()->getOpcode() == MSPU_ISD::XferAddr) {
        SDNode *Xfer = N->getOperand(2).getNode();
        if (isa<BlockAddressSDNode>(Xfer->getOperand(0).getNode())) {
          BlockAddressSDNode *OldLoopAddr =
            cast<BlockAddressSDNode>(Xfer->getOperand(0).getNode());
          SDValue LoopAddr =
            CurDAG->getBlockAddress(OldLoopAddr->getBlockAddress(),
                                    OldLoopAddr->getValueType(0),
                                    OldLoopAddr->getOffset(), true,
                                    OldLoopAddr->getTargetFlags());
          SDValue Chain = N->getOperand(0);
          SDValue Ops[] = { LoopAddr, N->getOperand(3), Chain };
          return CurDAG->getMachineNode(MSPUInst::LoopL0, SDLoc(N),
                                        N->getValueType(0), Ops);
        }
      }
      break;
    }
  }
    break;

    /*case ISD::FrameIndex:
     return getFrameIndex(N);*/

    //  DebugLoc dl = N->getDebugLoc();
    /*		case ISD::SDIV:
     case ISD::UDIV: {
     // FIXME: should use a custom expander to expose the SRA to the dag.
     SDValue DivLHS = N->getOperand(0);
     SDValue DivRHS = N->getOperand(1);

     // Set the Y register with the high-part.
     SDValue TopPart;
     if(N->getOpcode() == ISD::SDIV) {
     TopPart = SDValue(CurDAG->getMachineNode(MSPU::SRAri, dl, MVT::i32, DivLHS,
     CurDAG->getTargetConstant(31, MVT::i32)), 0);
     }
     else {
     TopPart = CurDAG->getRegister(MSPU::R21, MVT::i32);
     }

     /// getMachineNode - These are used for target selectors to create a new node
     /// with specified return type(s), MachineInstr opcode (not ISD opcode, important!!!),
     /// and operands.
     ///
     /// Note that getMachineNode returns the resultant node. If there is already
     /// a node of the specified opcode and operands, it returns that node instead
     /// of the current one (the newly created one is thus abandoned).
     /// to create a MachineNode, ...
     TopPart = SDValue(CurDAG->getMachineNode(MSPU::WRYrr, dl, MVT::Glue, TopPart,
     CurDAG->getRegister(MSPU::R21, MVT::i32)), 0);

     // FIXME: Handle div by immediate.
     unsigned Opcode = N->getOpcode() == ISD::SDIV? MSPU::SDIVrr : MSPU::UDIVrr;

     /// SelectNodeTo - These are used for target selectors to *mutate* the
     /// specified node to have the specified (1) return type, (2) target opcode, and
     /// (3) operands. Note that target opcodes are stored as
     /// ~TargetOpcode in the node opcode field. The resultant node is returned.
     // when a DAG node already exists, ...
     return CurDAG->SelectNodeTo(N, Opcode, MVT::i32, DivLHS, DivRHS, TopPart);
     }

     // MULHU/MULHS - Multiply high - Multiply two integers of type iN, producing
     // an unsigned/signed value of type i[2*N], then return the top part.
     case ISD::MULHU:
     case ISD::MULHS: {
     // FIXME: Handle mul by immediate.
     SDValue MulLHS = N->getOperand(0);
     SDValue MulRHS = N->getOperand(1);
     unsigned Opcode = N->getOpcode() == ISD::MULHU? MSPU::UMULrr : MSPU::SMULrr;
     SDNode *Mul = CurDAG->getMachineNode(Opcode, dl, MVT::i32, MVT::Glue, MulLHS, MulRHS);
     // The high part is in the Y register.
     return CurDAG->SelectNodeTo(N, MSPU::RDY, MVT::i32, SDValue(Mul, 1));
     }*/
  }

  return SelectCode(N);

}

/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
/// inline asm expressions.
bool
MSPUDAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
												char ConstraintCode,
												std::vector<SDValue> &OutOps)
{
	SDValue Op0, Op1;
	switch(ConstraintCode) {
		default:
			return true;
		case 'm':    // memory
			if(!SelectAddrJJ(Op, Op0, Op1))
				SelectAddrJImm(Op, Op0, Op1);
			break;
	}

	OutOps.push_back(Op0);
	OutOps.push_back(Op1);
	return false;
}

/// createMSPUISelDag - This pass converts a legalized DAG into a
/// MSPU-specific DAG, ready for instruction scheduling.
///
FunctionPass *
llvm::createMSPUISelDag(MSPUTargetMachine &TM)
{
	return new MSPUDAGToDAGISel(TM);
}
