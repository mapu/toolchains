/* This is a flex file for MSPU instruction lexer which cooperates with MSPU
 * instruction parser. This custom instruction lexer is a low-level, MSPU-specific
 * instruction lexer to analyze just one MSPU instruction line
 * (an VLIW instruction line). It is distinguished from LLVM platform generic
 * lexer and target-specific lexer. A similar description is created for MSPU
 * instruction parser.
 * See MSPUInstrParser.y for more details.
 */

%{
#include "MSPUGenInstrParser.h" // generated by bison, including definition of tokens and data types
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/MC/MCSymbol.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCContext.h"

using namespace llvm;
%}

/* list all needed compiling option so we can simplify makefiles */
/*
%option outfile="MSPUGenInstrLexer.flex"
*/
%option header-file="MSPUGenInstrFLexer.h"

%option case-insensitive

%option prefix="msputok"

%option bison-bridge
/*
%option bison-locations
*/

/* yywrap() is a function to invoke for EOF. */
%option noyywrap

/* suppress stdout for unmatched input */
%option nodefault

/* suppress unput() */
%option nounput

%% /*---------------------------section delimiter--------------------------------*/

	/* register classes with lower-case names */
r(0|([1-9][0-9]*)) {
		assert(atoi(yytext+1)<32);
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::I32RegRegClassID).getRegister(atoi(yytext+1)));
		return _RReg;
	}

j(0|([1-9][0-9]*)) {
		assert(atoi(yytext+1)<32);
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::PtrRegRegClassID).getRegister(atoi(yytext+1)));
		return _JReg;
	}

"sp" {
		yylval->op = MSPU::MSPUAsmOperand::createReg(MSPUReg::J29);
		return _JReg;
	}

"fp" {
		yylval->op = MSPU::MSPUAsmOperand::createReg(MSPUReg::J28);
		return _JReg;
	}

dr(0|([1-9][0-9]*)) {
		assert(atoi(yytext+2)<16);
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::F64RegRegClassID).getRegister(atoi(yytext+2)));
		return _DReg;
	}

kb(0|([1-9][0-9]*)) {
		assert(atoi(yytext+2)<16);
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::KBRegRegClassID).getRegister(atoi(yytext+2)));
		return _KReg;
	}

ke(0|([1-9][0-9]*)) {
		assert(atoi(yytext+2)<16);
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::KERegRegClassID).getRegister(atoi(yytext+2)));
		return _KReg;
	}

ks(0|([1-9][0-9]*)) {
		assert(atoi(yytext+2)<16);
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::KSRegRegClassID).getRegister(atoi(yytext+2)));
		return _KReg;
	}

ki(0|([1-9][0-9]*)) {
		assert(atoi(yytext+2)<16);
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::KIRegRegClassID).getRegister(atoi(yytext+2)));
		return _KReg;
	}

km(0|1|2) {
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::KMRegRegClassID).getRegister(atoi(yytext+2)));
		return _KMReg;
	}

kg(0|1|2) {
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::KGRegRegClassID).getRegister(atoi(yytext+2)));
		return _KReg;
	}

kl(0|1|2) {
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::KLRegRegClassID).getRegister(atoi(yytext+2)));
		return _KReg;
	}

mc[ \t]*\.[ \t]*r0 {
    yylval->op = MSPU::MSPUAsmOperand::createReg(MSPUReg::MC0);
    return _MCReg;
  }

mc[ \t]*\.[ \t]*r1 {
    yylval->op = MSPU::MSPUAsmOperand::createReg(MSPUReg::MC1);
    return _MCReg;
  }

mc[ \t]*\.[ \t]*w0 {
    yylval->op = MSPU::MSPUAsmOperand::createReg(MSPUReg::MC2);
    return _MCReg;
  }

mc[ \t]*\.[ \t]*w1 {
    yylval->op = MSPU::MSPUAsmOperand::createReg(MSPUReg::MC3);
    return _MCReg;
  }

mc[ \t]*\.[ \t]*w2 {
    yylval->op = MSPU::MSPUAsmOperand::createReg(MSPUReg::MC4);
    return _MCReg;
  }

svr(0|1) {
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::SVRRegRegClassID).getRegister(atoi(yytext+3)));
		return _SVRReg;
	}

shu(0|1) {
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::SHURegRegClassID).getRegister(atoi(yytext+3)));
		return _SHUReg;
	}

t(0|1|2|3) {
		yylval->op = MSPU::MSPUAsmOperand::createReg((MSPU::MSPUAsmParser::getRegInfo())->getRegClass(MSPUReg::TRegRegClassID).getRegister(atoi(yytext+1)));
		return _TReg;
	}

"cctrl" { return _CCtrl; }
"lpctr" { return _LPCtr; }
"cstat" { return _CStat; }
"mc"    { return _MC; }
"vect"  { return _Vect;}

"==" { return _EQ; }
"!=" { return _NE; }
">"  { return _GT; }
">=" { return _GE; }
"<"  { return _LT; }
"<=" { return _LE; }

"<<" { return _SL; }
">>" { return _SR; }


";" { return _Pl; }
";;" { return _EOS; }
"+=" { return _PlusE; }

"abs" 	 	{ return _Abs;}
"rsqrt" 	 	{ return _RSqRt;}
"recip" 	 	{ return _Recip;}
"single"	{ return _Single;}
"double"	{ return _Double;}
"int" 		{ return _Int;}
"uint" 		{ return _UInt;}
"jump" 		{ return _Jump;}
"call" 		{ return _Call;}
"callm" 		{ return _CallM;}
"syscall"     { return _SysCall;}
"if" 			{ return _If;}
"lpto" 		{ return _LpTo;}
"by" 			{ return _By;}
"stop"      |
"spu\.stop" |
"spustop" { return _Stop;}
"nop" { return _NOP;}
"ch" { return _CH;}
"stat" { return _Stat;}

"+"	|
"~"	|
"-"	|
"*"	|
"&"	|
"|"	|
"^"	|
"="	|
","	|
"." |
"["	|
"]"	|
"#" 	{return *yytext;}

\([ \t]*l0[ \t]*\) { return _L0;}
\([ \t]*l1[ \t]*\) { return _L1;}
\([ \t]*at[ \t]*\) { return _AT;}
\([ \t]*t[ \t]*\) { return _T;}
\([ \t]*b[ \t]*\) { return _B;}
\([ \t]*h[ \t]*\) { return _H;}
\([ \t]*l[ \t]*\) { return _L;}
\([ \t]*n[ \t]*\) { return _N;}
\([ \t]*u[ \t]*\) { return _U;}
\([ \t]*s[ \t]*\) { return _S;}
\([ \t]*d[ \t]*\) { return _D;}
\([ \t]*ci[ \t]*\) { return _CI;}
\([ \t]*x[ \t]*\) { return _X;}
\([ \t]*y[ \t]*\) { return _Y;}
\([ \t]*xy[ \t]*\) { return _XY;}

-?([0-9]+|(0x[0-9a-f]+))	{
		// yylval->op = MSPU::MSPUAsmOperand::createImm(strtol(yytext, NULL, 0));
		return _Imm;
	}

-?[0-9]+\.[0-9]*                |
-?[0-9]+\.[0-9]*(e[-+]?[0-9]+)  |
-?\.[0-9]+			          |
-?\.[0-9]+(e[-+]?[0-9]+)  |
-?[0-9]+(e[-+]?[0-9]+)     {
		yylval->op = MSPU::MSPUAsmOperand::createFPImm(strtod(yytext, NULL));
		return _FPImm;
	}

[_a-zA-Z][_a-zA-Z0-9]* {
    //StringRef * ref = new StringRef(MSPU::MSPUAsmParser::getParser()->getTok().getString().data(), strlen(yytext));
    //yylval->op = MSPU::MSPUAsmOperand::createExpr(ref);
		return _Symb;
	}

[ \t\n]+			{}

. 	{ return _Err; /*printf("flex scanned unknown character: %c\n", *yytext);*/ }
