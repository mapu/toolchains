//===-- MMPUAPDLGen.cpp - MMPU APDL Generator------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===--------------------------------------------------------------------===//
//
//
//===--------------------------------------------------------------------===//

#include "MMPUAPDLGen.h"
#include "MMPUAST.h"
#include "MMPUSymbol.h"
#include "MMPUBlock.h"
#include "AsmParser/MMPULiteScheduler.h"
#include <list>

using namespace llvm;
using namespace Lite;
using namespace MMPULite;

namespace llvm
{
  
const unsigned BF=0, HF=1, UF=2, TF=3, SF=4, DF=5, IF=6, LF=7, APPF=8, KPPF=9, CRF=10, BRF=11, MF=12, TCF=13;
  
class MMPULiteInstPrinter {
public:
  MMPULiteInstPrinter() { }
    
  void printInst(const MCInst *MI, raw_ostream &O, StringRef Annot);
    
  /****************** autogenerated by tblgen ********************/
  void printInstruction(const MCInst *MI, raw_ostream &O);
    
  static const char *getRegisterName(unsigned RegNo);
  /***************************************************************/
    
  void printOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;
    
  void printFlags(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;
    
  void printKIReg(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;
    
  void printIPath(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;
    
  void printMACCTI(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;
    
  void printSHUT(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;
};
}

void MMPULiteInstPrinter::printInst(const MCInst *MI, raw_ostream &O,
                                    StringRef Annot) {
  O<<"\t"; // at start of line
    
  bool isAllNOP = true; // test whether all inst are NOP
  const MCInst *curinst = MI;
  std::string split = "";
  do {
    if (curinst == MI)
      curinst = curinst->getOperand(0).getInst();
    else
      curinst = curinst->getOperand(curinst->getNumOperands()-1).getInst();
    if (curinst->getOpcode() != MMPULite::NOP) {
      O << split;
      printInstruction(curinst, O);
      split = "|| ";
      isAllNOP = false;
    }
  } while (curinst->getNumOperands() &&
           curinst->getOperand(curinst->getNumOperands()-1).isInst());
  if(isAllNOP) {
    O << "NOP";
  }
  O << ";";
  //printAnnotation(O, Annot);
    
  return;
}
  
void MMPULiteInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
                                       raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);
    
  if (MO.isReg()) {
    O << getRegisterName(MO.getReg());
  } else if (MO.isExpr()) {
    O << *(MO.getExpr());
  } else if (MO.isImm())
    switch(MI->getOpcode()) {
    case MMPULite::LPTO:
    case MMPULite::JUMP:
    case MMPULite::JUMPK:
      if (OpNo == 0)
        O << "(" << MO.getImm() << "f)";
      else
        O << MO.getImm();
      break;
    default:
      O << MO.getImm();
      break;
    }
  else {
    assert(false && "Unknown operand");
  }
}

void MMPULiteInstPrinter::printFlags(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);
    
  int64_t flags = MO.getImm();
  
  std::string comma = "";
  if (flags) {
    O << "(";
    if(flags & (1 << BF)) {O << comma << "B"; comma = ", ";}
    if(flags & (1 << HF)) {O << comma << "H"; comma = ", ";}
    if(flags & (1 << UF)) {O << comma << "U"; comma = ", ";}
    if(flags & (1 << TF)) {O << comma << "T"; comma = ", ";}
    if(flags & (1 << SF)) {O << comma << "S"; comma = ", ";}
    if(flags & (1 << DF)) {O << comma << "D"; comma = ", ";}
    if(flags & (1 << IF)) {O << comma << "I"; comma = ", ";}
    if(flags & (1 << LF)) {O << comma << "L"; comma = ", ";}
    if(flags & (1 << APPF)) {O << comma << "A++"; comma = ", ";}
    if(flags & (1 << KPPF)) {O << comma << "K++"; comma = ", ";}
    if(flags & (1 << CRF)) {O << comma << "CR"; comma = ", ";}
    if(flags & (1 << BRF)) {O << comma << "BR"; comma = ", ";}
    if(flags & (1 << MF)) {O << comma << "M"; comma = ", ";}
    if(flags & (1 << TCF)) {O << comma << "TC"; comma = ", ";}
    O << ")";
  }
}

void MMPULiteInstPrinter::printKIReg(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);
    
  unsigned kis = (MO.getImm()) & 0x3F;
  if (kis & 0x10) O << "!";
  O << "KI" << (kis & 0xF);
  kis = (MO.getImm()>>5) & 0x3F;
  if (kis) {
    O << "&";
    if (kis & 0x10) O << "!";
    O << "KI" << (kis & 0xF);
  }
  kis = (MO.getImm()>>11) & 0x3F;
  if (kis) {
    O << "&";
    if (kis & 0x10) O << "!";
    O << "KI" << (kis & 0xF);
  }
  kis = MO.getImm()>>17;
  if (kis) {
    O << "&";
    if (kis & 0x10) O << "!";
    O << "KI" << (kis & 0xF);
  }
}

void MMPULiteInstPrinter::printIPath(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);
    
  unsigned path = (MO.getImm()) & 0x3;
  if (path)
    O << "(I" << path - 1 << ")";
}
  
void MMPULiteInstPrinter::printMACCTI(const MCInst *MI, unsigned int OpNo,
                                      raw_ostream &O) const {
  printOperand(MI, OpNo, O);
  O << ".";
  printOperand(MI, OpNo + 1, O);
  printIPath(MI, OpNo + 2, O);
}
  
void MMPULiteInstPrinter::printSHUT(const MCInst *MI,
                                    unsigned int OpNo,
                                    raw_ostream &O) const {
  printOperand(MI, OpNo, O);
  O << ".";
  printOperand(MI, OpNo + 1, O);
}

#include "MMPULiteGenAsmWriter.inc"

namespace MMPU {
  
void APDLGen::GenAPDLInst(MMPU::Block *BAst) {
  if (!APDLFunc) APDLFunc = new MCLoopBlock(Sequential, 0);
  MCLoopBlock *top = APDLFunc;
  APDLFunc = APDLFunc->addSubBlock(new MCLoopBlock(Sequential, 0));
  if (BAst && BAst->isAPDLBlock()) {
    if (BAst->getType() == Block::BLOCK_AST) genAST(BAst->getAST());
    else genBlock(BAst);
  }
  APDLFunc = top;
}
  
void APDLGen::genBlock(MMPU::Block *B) {
  Block *child;
  MCLoopBlock *NewLoop;
  for (unsigned i = 0; i < B->Size(); i++) {
    child = B->getChild(i);
    switch (child->getType()) {
    case Block::BLOCK_AST:
      genAST(child->getAST());
      break;
    
    case Block::BLOCK_WHILE:
      /* Reorganize the structure of MCLoopBlock in order to insert
       a loop block. */
      child->setIndex(PrevSym);
      if (APDLFunc->getType() == Loop)
        APDLFunc = APDLFunc->addSubBlock(
          new MCLoopBlock(Loop, 0, 0, child->getIndex()->getID()));
      else if (APDLFunc->size() == 0)
        APDLFunc->setType(Loop, 0, child->getIndex()->getID());
      else if (APDLFunc->getParent())
        APDLFunc = APDLFunc->addSiblingBlock(
          new MCLoopBlock(Loop, 0, 0, child->getIndex()->getID()));
      NewLoop = APDLFunc;
      genBlock(child);
      LoopInfoMap[NewLoop->getKI()].KReg = NewLoop->getKI();
      if (!NewLoop->isNested()) {
        LoopInfoMap[NewLoop->getKI()].OrigSize = NewLoop->size();
        LoopInfoMap[NewLoop->getKI()].SplitSize = NewLoop->size();
      }
      APDLFunc = APDLFunc->addSubBlock(new MCLoopBlock(Sequential, 0));
      break;
    
    case Block::BLOCK_DECL:
      genBlock(child);
      break;
        
    default:
      break;
    }
  }
  if (B->getType() == Block::BLOCK_WHILE)
    APDLFunc = APDLFunc->getParent();
}
  
void APDLGen::genAST(ExprAST *E) {
  /* most probably this is an expression statement */
  TagExprAST::TagTy tag = TagExprAST::INVALIDTAG;
  
  if (E && E->getNext() && isa<TagExprAST>(E->getNext()))
    tag = dyn_cast<TagExprAST>(E->getNext())->getTag();
  
  switch (tag) {
  case TagExprAST::EXPR_ASSIGN:
    Gen_Assign(E);
    break;
      
  default:
    break;
  }
}
  
void APDLGen::Gen_Assign(ExprAST *Expr) {
  ExprAST *e1 = NULL, *e2 = NULL;
  TagExprAST::TagTy dest;
  unsigned Fixup = 0;
  unsigned Fixedopc = 0;
  Symbol *s = NULL;  
  SmallVector<SharedOperand, 8> Operands;
  
  if (Expr && Expr->getNext()->getNext() &&
      isa<ExprExprAST>(Expr->getNext()->getNext())) {
    e1 = dyn_cast<ExprExprAST>(Expr->getNext()->getNext())->getExpr();
    if (Expr->getNext()->getNext()->getNext() &&
        isa<ExprExprAST>(Expr->getNext()->getNext()->getNext()))
      e2 = dyn_cast<ExprExprAST>(Expr->getNext()->getNext()
                                     ->getNext())->getExpr();
  }
  
  dest = getLValType(e1);
  
  if (dest == TagExprAST::STORAGE_MACREG) {
    Gen_AssignOp(e1, e2);
    return;
  }
  
  if (dest != TagExprAST::STORAGE_KREG) {
    Operands.push_back(NULL); // Opcode
    Operands.push_back(NULL); // Dest
    if (dest == TagExprAST::STORAGE_TREG) {
      Operands.push_back(NULL); // T
      Operands.push_back(NULL); // I
    }
    if (dest != TagExprAST::STORAGE_DM) Operands.push_back(NULL); // VReg
    Operands.push_back(SHARED_OPRD(Reg, MMPULiteReg::NOC, SMLoc(), SMLoc()));
  
    Gen_RVal(e2, Operands);
  }
  switch (dest) {
  case TagExprAST::STORAGE_DM:
    if (e1 && e1->getNext() && e1->getNext()->getNext() &&
        isa<SymExprAST>(e1->getNext()->getNext())) {
      s = dyn_cast<SymExprAST>(e1->getNext()->getNext())->getSymbol();
      if (s) {
        if (s->getID() == -1) {
          s->Allocate(BIUID++);
        }
        DestStack.push_back(s->getID());
      }
    }
    Operands[1] = SHARED_OPRD(Reg, MMPULiteReg::BIU0 + s->getID(), SMLoc(),
                              SMLoc());
    Fixup = 0;
    /* it's not completed for BIU store.
       A BIU store operation consists of two parts:
       1. ->BIUx, this is done by here
       2. BIUx->DM, this is emitted after 1.
       the later one is a terminal inst */
    break;
      
  case TagExprAST::STORAGE_MREG:
    if (e1 && e1->getNext() && e1->getNext()->getNext() &&
        isa<SymExprAST>(e1->getNext()->getNext())) {
      s = dyn_cast<SymExprAST>(e1->getNext()->getNext())->getSymbol();
      if (s) {
        // if (s->getID() == -1)
        /* an MReg variable may be allocated several times, they are
           different versions of the variable, hence to approach the
           SSA purpose */
        s->Allocate(AllocateVReg(TagExprAST::STORAGE_MREG));
        DestStack.push_back(s->getID());
      }
    }
    Operands[1] = SHARED_OPRD(Reg, MMPULiteReg::M0, SMLoc(), SMLoc());
    Operands[2] = SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc());
    Fixup = 1;
    break;
      
  case TagExprAST::STORAGE_TREG:
    /* use IALU.T0 to represent any unallocated TReg, and deal with TReg
       allocation later */
    Operands[1] = SHARED_OPRD(Reg, MMPULiteReg::IALU, SMLoc(), SMLoc());
    Operands[2] = SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc());
      
    /* allocate a virtual TReg */
    if (e1 && e1->getNext() && e1->getNext()->getNext() &&
        isa<SymExprAST>(e1->getNext()->getNext())) {
      s = dyn_cast<SymExprAST>(e1->getNext()->getNext())->getSymbol();
      if (s) {
        //if (s->getID() == -1)
        s->Allocate(AllocateVReg(TagExprAST::STORAGE_TREG));
        DestStack.push_back(s->getID());
      }
    }
    Operands[3] = SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc());
    /* here is an optional operand for IPath which depends on the
       dest of the next inst, determine it later */
    Operands[4] = SHARED_OPRD(Imm, 0, SMLoc(), SMLoc()); // IPath
    Fixup = 2;
    break;
      
  case TagExprAST::STORAGE_KREG:
    /* A KReg assignment is found, the only legal situation is that a loop
       block is following */
    if (e1 && e1->getNext() && e1->getNext()->getNext() &&
        isa<SymExprAST>(e1->getNext()->getNext())) {
      s = dyn_cast<SymExprAST>(e1->getNext()->getNext())->getSymbol();
      if (s) {
        s->Allocate(AllocateKReg());
      }
      PrevSym = s;
    }
    return;
      
  default:
    break;
  }
  
  unsigned tag = TagExprAST::INVALIDTAG;
  if (e2 && e2->getNext() && isa<TagExprAST>(e2->getNext()))
    tag = dyn_cast<TagExprAST>(e2->getNext())->getTag();
  if (tag != TagExprAST::EXPR_IDENT && tag!= TagExprAST::EXPR_APDLINC) {
    Fixedopc = CAST_TO_MMPU_OPRD(Operands[0])->getOpc() + Fixup;
    //delete Operands[0];
  
    Operands[0] = SHARED_OPRD(Opc, Fixedopc, SMLoc(), SMLoc());
  }
  
  addParsedInst(new MCParsedInst(Operands));
  if (CAST_TO_MMPU_OPRD(Operands[0])->getOpc() >= IMRToBIU &&
      CAST_TO_MMPU_OPRD(Operands[0])->getOpc() <= IMRToSHU)
    FragmentInsts.push_back(APDLFunc->getInsts().back());
  
  if (dest == TagExprAST::STORAGE_DM) {
    Operands.clear();
    Operands.push_back(SHARED_OPRD(Opc, (BIU0St + s->getID() * (BIU1St - BIU0St)),
                               SMLoc(), SMLoc()));
    Operands.push_back(SHARED_OPRD(Reg, MMPULiteReg::NOC, SMLoc(), SMLoc()));
    /* Flags should be checked if here is BIU or BIU++ to determine if (A++, K++)
       is required, but in practical, flags are always needed by DM store. */
    Flags.set(APPF);
    Flags.set(KPPF);
    Operands.push_back(SHARED_OPRD(Imm, Flags.to_ulong(), SMLoc(), SMLoc()));
    Flags.reset();
    Operands.push_back(SHARED_OPRD(Slot, 10 + s->getID(), SMLoc(), SMLoc()));
    SrcStack.push_back(s->getID());
    addParsedInst(new MCParsedInst(Operands));
  }
}
  
  /* Gen_AssignOp: Generate code for "ident += expression".
     The frontend only supports following usage of IMAC unit:
     1. mac var += expression
     2. mac var += expression * expression
     (Not supported)3. dm/mreg/treg var += expression
     (Not supported)4. dm/mreg/treg var += expression * expression
     5. mac var = expression + expression * expression
     6. mac var = expression * expression + expression
     7. mac var = 0
     Note: mac var is unable to be referred or read alone.
     dm/mreg/treg = mac var + expression OR 
     dm/mreg/treg = expression + mac var <=> dm/mreg/treg += expression
   */
  
void APDLGen::Gen_AssignOp(ExprAST *D, ExprAST *E) {
  SmallVector<SharedOperand, 8> Operands;
  
  TagExprAST::TagTy tag = TagExprAST::INVALIDTAG,
                    tag1 = TagExprAST::INVALIDTAG,
                    tag2 = TagExprAST::INVALIDTAG;
  Symbol *s = NULL;
  ExprAST *e1 = NULL, *e2 = NULL;
  
  if (E && E->getNext() && isa<TagExprAST>(E->getNext()))
    tag = dyn_cast<TagExprAST>(E->getNext())->getTag();
  
  if (E && E->getNext()->getNext() &&
      isa<ExprExprAST>(E->getNext()->getNext())) {
    e1 = dyn_cast<ExprExprAST>(E->getNext()->getNext())->getExpr();
    if (E->getNext()->getNext()->getNext() &&
        isa<ExprExprAST>(E->getNext()->getNext()->getNext()))
      e2 = dyn_cast<ExprExprAST>(E->getNext()->getNext()->getNext())->getExpr();
  }
  
  enum macinst {
    NA = 0,
    MAC,
    MAC_CR,
    MA,
    MA_CR,
    ACC,
    ACC_CR
  } insttype = NA;
  
  std::vector<ExprAST *> SubExpr;
  switch (tag) {
  case TagExprAST::EXPR_INT:
    // mr = 0
    Gen_Const(E, Operands);
    if (CAST_TO_MMPU_OPRD(Operands.back())->getImm())
      errs() << "Initializing MR with non-zero immediate number.\n";
    else {
      /* Clearing mr register is found isolated from any mac operation.
         Save this event until it can be determined that with which mac
         operation it works. */
      if (D && D->getNext() && D->getNext()->getNext() &&
          isa<SymExprAST>(D->getNext()->getNext())) {
        s = dyn_cast<SymExprAST>(D->getNext()->getNext())->getSymbol();
        // Allocate a VReg for a mac variable with NO producer.
        if (s) s->Allocate(AllocateVReg(TagExprAST::STORAGE_MACREG));
      }
    }
    return;
    
  case TagExprAST::EXPR_IDENT:
    // mr += ident (CR)
    if (getLValType(E) != TagExprAST::STORAGE_MACREG) {
      SubExpr.push_back(E);
      insttype = ACC_CR;
    }
    else errs() << "Found illegal expression \"mr = mr\" ?\n";
    break;
      
  case TagExprAST::EXPR_SADD:
  case TagExprAST::EXPR_ADD:
    // mr += ...
    if (e1 && e1->getNext() && isa<TagExprAST>(e1->getNext()))
      tag1 = dyn_cast<TagExprAST>(e1->getNext())->getTag();
    if (e2 && e2->getNext() && isa<TagExprAST>(e2->getNext()))
      tag2 = dyn_cast<TagExprAST>(e2->getNext())->getTag();
    if (tag1 == TagExprAST::EXPR_IDENT && tag2 == TagExprAST::EXPR_IDENT) {
      if ((getLValType(e1) == TagExprAST::STORAGE_MACREG) ^
          (getLValType(e2) == TagExprAST::STORAGE_MACREG)) {
        // mr += ident
        insttype = ACC;
        if (getLValType(e1) == TagExprAST::STORAGE_MACREG) {
          SubExpr.push_back(e2);
          E = e2;
        } else {
          SubExpr.push_back(e1);
          E = e1;
        }
      } if ((getLValType(e1) != TagExprAST::STORAGE_MACREG) &&
            (getLValType(e2) != TagExprAST::STORAGE_MACREG)) {
        // expr = ident + ident
        // mr += expr (CR)
        insttype = ACC_CR;
        SubExpr.push_back(E);
      } else errs() << "Found illegal expression \"mr += mr\" ?\n";
    } else if ((tag1 == TagExprAST::EXPR_IDENT) ^
               (tag2 == TagExprAST::EXPR_IDENT)) {
      if ((getLValType(e1) == TagExprAST::STORAGE_MACREG) ||
          (getLValType(e2) == TagExprAST::STORAGE_MACREG)) {
        if ((tag1 == TagExprAST::EXPR_MUL) || (tag2 == TagExprAST::EXPR_MUL)) {
          // mr += expr * expr
          insttype = MAC;
          ExprAST *Mul;
          if (tag1 == TagExprAST::EXPR_MUL) {
            E = e2;
            Mul = e1;
          } else {
            Mul = e2;
            E = e1;
          }
          if (Mul && Mul->getNext()->getNext() &&
              isa<ExprExprAST>(Mul->getNext()->getNext())) {
            e1 = dyn_cast<ExprExprAST>(Mul->getNext()->getNext())->getExpr();
            if (Mul->getNext()->getNext()->getNext() &&
                isa<ExprExprAST>(Mul->getNext()->getNext()->getNext()))
              e2 = dyn_cast<ExprExprAST>(Mul->getNext()->getNext()->getNext())->getExpr();
          }
          SubExpr.push_back(e1);
          SubExpr.push_back(e2);
        } else {
          // mr += expr
          insttype = ACC;
          if (getLValType(e1) == TagExprAST::STORAGE_MACREG) {
            SubExpr.push_back(e2);
            E = e1;
          } else {
            SubExpr.push_back(e1);
            E = e2;
          }
        }
      } else {
        // mr += expr (CR)
        insttype = ACC_CR;
        SubExpr.push_back(E);
      }
    } else {
      // mr += expr + expr (CR)
      insttype = ACC_CR;
      SubExpr.push_back(E);
    }
      
    break;
  
  case TagExprAST::EXPR_MUL:
    // mr += expr * expr (CR)
    insttype = MAC_CR;
    SubExpr.push_back(e1);
    SubExpr.push_back(e2);
    break;
      
  default:
    // mr += expr (CR)
    SubExpr.push_back(E);
    insttype = ACC_CR;
    break;
  }
  
  switch (insttype) {
  case ACC:
  case ACC_CR:
    Operands.push_back(SHARED_OPRD(Opc, MMPULite::IMAcc, SMLoc(), SMLoc()));
    break;
      
  case MA:
  case MA_CR:
    errs() << "MA\n";
    Operands.push_back(SHARED_OPRD(Opc, MMPULite::IMA, SMLoc(), SMLoc()));
    break;
  
  case MAC:
  case MAC_CR:
    Operands.push_back(SHARED_OPRD(Opc, MMPULite::IMaC, SMLoc(), SMLoc()));
    break;
      
  default:
    break;
  }
  
  Operands.push_back(SHARED_OPRD(Reg, MMPULiteReg::MR, SMLoc(), SMLoc()));
  Operands.push_back(NULL); // VReg ID
  Operands.push_back(SHARED_OPRD(Reg, MMPULiteReg::NOC, SMLoc(), SMLoc()));
  std::vector<uint64_t> src;
  bool BackofNT = needTemp;
  needTemp = true;
  for (unsigned i = 0; i < SubExpr.size(); i++) {
    Gen_RVal(SubExpr[i], Operands);
    src.push_back(CAST_TO_MMPU_OPRD(Operands.back())->getImm());
  }
  needTemp = BackofNT;
  SrcStack = src;
  
  /* generate flags */
  switch (insttype) {
  case ACC_CR:
  case MA_CR:
  case MAC_CR:
    Flags.set(CRF);
    break;
      
  case ACC:
  case MA:
  case MAC:
    if (E && E->getNext() && E->getNext()->getNext() &&
        isa<SymExprAST>(E->getNext()->getNext())) {
      s = dyn_cast<SymExprAST>(E->getNext()->getNext())->getSymbol();
      SrcStack.push_back(s->getID());
    }
    break;
    
  default:
    break;
  }
  
  Operands.push_back(SHARED_OPRD(Imm, Flags.to_ulong(), SMLoc(), SMLoc()));
  Flags.reset();
  
  Operands.push_back(SHARED_OPRD(Slot, 7, SMLoc(), SMLoc()));
  
  if (D && D->getNext() && D->getNext()->getNext() &&
      isa<SymExprAST>(D->getNext()->getNext())) {
    s = dyn_cast<SymExprAST>(D->getNext()->getNext())->getSymbol();
    s->Allocate(AllocateVReg(TagExprAST::STORAGE_MACREG));
    DestStack.push_back(s->getID());
  }
  Operands[2] = SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc());
  addParsedInst(new MCParsedInst(Operands));
}
  
  // getLValType: get the storage type of the left hand side variable 
TagExprAST::TagTy APDLGen::getLValType(ExprAST *E) {
  TagExprAST::TagTy tag = TagExprAST::INVALIDTAG;
  Symbol *s = NULL;
  TagExprAST *storage = NULL;
    
  if (E && E->getNext() && isa<TagExprAST>(E->getNext()))
    tag = dyn_cast<TagExprAST>(E->getNext())->getTag();
    
  if (tag != TagExprAST::EXPR_IDENT && tag != TagExprAST::EXPR_APDLINC)
    return tag;
  
  if (E->getNext()->getNext() && isa<SymExprAST>(E->getNext()->getNext()))
    s = dyn_cast<SymExprAST>(E->getNext()->getNext())->getSymbol();
  
  if (s && s->getExpr())
    storage = dyn_cast_or_null<TagExprAST>(s->getExpr()->getNext());
  
  if (storage) return storage->getTag();
  else return TagExprAST::INVALIDTAG;
}

  
void APDLGen::Gen_Const(ExprAST *E, SharedOperandVector &O) {
  int64_t c = 0;
  if (E && E->getNext() && E->getNext()->getNext() &&
        isa<IntExprAST>(E->getNext()->getNext()))
    c = dyn_cast<IntExprAST>(E->getNext()->getNext())->getVal();
  O.push_back(SHARED_OPRD(Imm, c, SMLoc(), SMLoc()));
}
  
void APDLGen::Gen_RVal(ExprAST *E, SharedOperandVector &O) {

  TagExprAST::TagTy tag = TagExprAST::INVALIDTAG;
  SmallVector<SharedOperand, 8> BackO;
  uint64_t tempT;
  
  if (E && E->getNext() && isa<TagExprAST>(E->getNext()))
    tag = dyn_cast<TagExprAST>(E->getNext())->getTag();
  
  switch (tag) {
      
  case TagExprAST::EXPR_INT:
    Gen_Const(E, O);
    break;
      
  case TagExprAST::EXPR_IDENT:
  case TagExprAST::EXPR_APDLINC:
    Gen_RIdent(E, O);
    break;
      
  case TagExprAST::EXPR_ASSIGN:
    /* adjacent two assignments are not supported */
    break;
  
  case TagExprAST::EXPR_ADD:
  case TagExprAST::EXPR_SUB:
  case TagExprAST::EXPR_SADD:
  case TagExprAST::EXPR_SSUB:
  case TagExprAST::EXPR_MOD:
  case TagExprAST::EXPR_AND:
  case TagExprAST::EXPR_OR:
  case TagExprAST::EXPR_XOR:
  case TagExprAST::EXPR_SHR:
  case TagExprAST::EXPR_SHL:
      
  case TagExprAST::EXPR_LT:
  case TagExprAST::EXPR_LE:
  case TagExprAST::EXPR_GT:
  case TagExprAST::EXPR_GE:
  case TagExprAST::EXPR_EQ:
  case TagExprAST::EXPR_NE:
    if (needTemp) {
      tempT = AllocateVReg(TagExprAST::STORAGE_TREG);
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
      O.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc()));
      for (unsigned i = 0; i < O.size(); i++)
        BackO.push_back(O[i]);
      O.clear();
      O.push_back(SHARED_OPRD(Opc, MMPULite::IALUBinToMACC, SMLoc(), SMLoc())); // Opcode
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::IALU, SMLoc(), SMLoc()));
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc())); // T
      O.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc())); // VReg
      O.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc())); // I
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::NOC, SMLoc(), SMLoc()));
    } else
      O[0] = SHARED_OPRD(Opc, MMPULite::IALUBinToBIU, SMLoc(), SMLoc());
    Gen_IALU_Binary(E, tag, O);
    if (needTemp) {
      DestStack.push_back(tempT);
      addParsedInst(new MCParsedInst(O));
      O.clear();
      for (unsigned i = 0; i < BackO.size(); i++)
        O.push_back(BackO[i]);
      BackO.clear();
    }
    break;
      
  case TagExprAST::EXPR_MUL:
    if (needTemp) {
      tempT = AllocateVReg(TagExprAST::STORAGE_TREG);
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
      O.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc()));
      for (unsigned i = 0; i < O.size(); i++)
        BackO.push_back(O[i]);
      O.clear();
      O.push_back(SHARED_OPRD(Opc, MMPULite::IMulToMACC, SMLoc(), SMLoc())); // Opcode
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::IALU, SMLoc(), SMLoc()));
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc())); // T
      O.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc())); // VReg
      O.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc())); // I
      O.push_back(SHARED_OPRD(Reg, MMPULiteReg::NOC, SMLoc(), SMLoc()));
    } else
      O[0] = SHARED_OPRD(Opc, MMPULite::IMulToBIU, SMLoc(), SMLoc());
    Gen_IMAC_Binary(E, tag, O);
    if (needTemp) {
      DestStack.push_back(tempT);
      addParsedInst(new MCParsedInst(O));
      O.clear();
      for (unsigned i = 0; i < BackO.size(); i++)
        O.push_back(BackO[i]);
      BackO.clear();
    }
    break;
      
  case TagExprAST::EXPR_DIV:
  
    break;
      
  case TagExprAST::EXPR_NOT:
      //Gen_ExprUnary(E, not_i, not_i);
    break;
  case TagExprAST::EXPR_NEG:
      //Gen_ExprUnary(E, neg_i, neg_i);
    break;
      
  case TagExprAST::EXPR_LAND:
  case TagExprAST::EXPR_LOR:
    /* unsupported */
    break;
      
  case TagExprAST::EXPR_COND:
      //Gen_ExprCond(E);
    break;
  default:
    break;
  }
}

void APDLGen::Gen_IALU_Binary(ExprAST *E, TagExprAST::TagTy Op,
                              SharedOperandVector &O) {
  ExprAST *e1 = NULL, *e2 = NULL;
  uint64_t src = 0;
  
  switch (Op) {
  case TagExprAST::EXPR_SADD:
  case TagExprAST::EXPR_ADD:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::IADD, SMLoc(), SMLoc()));
    break;
      
  case TagExprAST::EXPR_SSUB:
  case TagExprAST::EXPR_SUB:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::ISUB, SMLoc(), SMLoc()));
    break;
    
      //case TagExprAST::EXPR_MUL:
      //case TagExprAST::EXPR_DIV:
      //case TagExprAST::EXPR_MOD:
  case TagExprAST::EXPR_AND:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::AND, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_OR:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::OR, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_XOR:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::XOR, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_SHR:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::RSHT, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_SHL:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::LSHT, SMLoc(), SMLoc()));
    break;
      
  case TagExprAST::EXPR_LT:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::IST, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_LE:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::INLT, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_GT:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::ILT, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_GE:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::INST, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_EQ:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::IEQU, SMLoc(), SMLoc()));
    break;
  case TagExprAST::EXPR_NE:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::INEQ, SMLoc(), SMLoc()));
    break;

  default:
    break;
  }
  
  if (E && E->getNext() && E->getNext()->getNext() &&
      isa<ExprExprAST>(E->getNext()->getNext())) {
    e1 = dyn_cast<ExprExprAST>(E->getNext()->getNext())->getExpr();
    if (E->getNext()->getNext()->getNext() &&
        isa<ExprExprAST>(E->getNext()->getNext()->getNext()))
      e2 = dyn_cast<ExprExprAST>(E->getNext()->getNext()->getNext())->getExpr();
  }
  
  bool BackupNT = needTemp;
  needTemp = true;
  Gen_RVal(e1, O);
  src = CAST_TO_MMPU_OPRD(O.back())->getImm();
  Gen_RVal(e2, O);
  needTemp = BackupNT;
  
  SrcStack.push_back(src);
  src = CAST_TO_MMPU_OPRD(O.back())->getImm();
  SrcStack.push_back(src);
  
  // The third operand of binary ops is not used, but is required by printer
  O.push_back(SHARED_OPRD(Reg, MMPULiteReg::T0, SMLoc(), SMLoc()));

  /* generate flags */
  switch (Op) {
  case TagExprAST::EXPR_ADD:
  case TagExprAST::EXPR_SUB:
    Flags.set(TF);
    break;
      
  default:
    break;
  }
  O.push_back(SHARED_OPRD(Imm, Flags.to_ulong(), SMLoc(), SMLoc()));
  Flags.reset();
  
  O.push_back(SHARED_OPRD(Slot, 6, SMLoc(), SMLoc()));
}
  
void APDLGen::Gen_IMAC_Binary(ExprAST *E, TagExprAST::TagTy Op,
                              SharedOperandVector &O) {
  ExprAST *e1 = NULL, *e2 = NULL;
  uint64_t src = 0;
  
  switch (Op) {
  case TagExprAST::EXPR_MUL:
  //case TagExprAST::EXPR_DIV:
  //case TagExprAST::EXPR_MOD:
    O.push_back(SHARED_OPRD(Reg, MMPULiteReg::IMUL, SMLoc(), SMLoc()));
    break;
      
  default:
    break;
  }
  
  if (E && E->getNext()->getNext() &&
      isa<ExprExprAST>(E->getNext()->getNext())) {
    e1 = dyn_cast<ExprExprAST>(E->getNext()->getNext())->getExpr();
    if (E->getNext()->getNext()->getNext() &&
        isa<ExprExprAST>(E->getNext()->getNext()->getNext()))
      e2 = dyn_cast<ExprExprAST>(E->getNext()->getNext()->getNext())->getExpr();
  }
  
  bool BackofNT = needTemp;
  needTemp = true;
  Gen_RVal(e1, O);
  src = CAST_TO_MMPU_OPRD(O.back())->getImm();
  Gen_RVal(e2, O);
  needTemp = BackofNT;
  
  SrcStack.push_back(src);
  src = CAST_TO_MMPU_OPRD(O.back())->getImm();
  SrcStack.push_back(src);
  
  /* generate flags */
  switch (Op) {
  case TagExprAST::EXPR_MUL:
    Flags.set(TF);
    break;
      
  default:
    break;
  }
  O.push_back(SHARED_OPRD(Imm, Flags.to_ulong(), SMLoc(), SMLoc()));
  Flags.reset();
  
  O.push_back(SHARED_OPRD(Slot, 7, SMLoc(), SMLoc()));
}
  
void APDLGen::Gen_RIdent(ExprAST *E, SharedOperandVector &O) {
  TagExprAST::TagTy t = getLValType(E);
  Symbol *s = NULL;
  SmallVector<SharedOperand, 8> LoadO;
  uint64_t tempT;
  unsigned dist = BIU1LdToM - BIU0LdToM;
  int64_t Slot;
  TagExprAST::TagTy isInc = TagExprAST::INVALIDTAG;
  ExprAST *Index = NULL;
  
  if (E && E->getNext() && E->getNext()->getNext() &&
      isa<SymExprAST>(E->getNext()->getNext())) {
    isInc = dyn_cast<TagExprAST>(E->getNext())->getTag();
    s = dyn_cast<SymExprAST>(E->getNext()->getNext())->getSymbol();
  }
  
  if (E && E->getNext() && E->getNext()->getNext() &&
      E->getNext()->getNext()->getNext()) {
    Index = E->getNext()->getNext()->getNext();
    
    if (Index && Index->getNext() && isa<TagExprAST>(Index->getNext()))
      isInc = dyn_cast<TagExprAST>(Index->getNext())->getTag();
  }
  
  if (!needTemp) {
    /* Solo identifier on the right hand of assignment:
       dmem = mreg : store mreg to dm
       dmem = treg : illegal
       dmem = dmem : illegal
       mreg = mreg : legal only if load from M.r0
       mreg = treg : illegal
       mreg = dmem : load mreg from dm
       treg = mreg : load treg from mreg
       treg = dmem : load treg from dm
       treg = treg : only allowed load treg from shu treg
       dmem/mreg/treg = mac : psuedo
       mac  = dmem/mreg/treg : should not happen here
       */
    // dedute which type of storage the dest is
    TagExprAST::TagTy dest = TagExprAST::INVALIDTAG;
    if (O.size() == 3) dest = TagExprAST::STORAGE_DM;
    else if (O.size() == 4) dest = TagExprAST::STORAGE_MREG;
    else if (O.size() == 6) dest = TagExprAST::STORAGE_TREG;
    if (t == TagExprAST::STORAGE_DM) {
      if (s) {
        if (s->getID() == -1)
          s->Allocate(BIUID++);
        unsigned op = BIU0LdToM + s->getID() * dist;
        if (dest == TagExprAST::STORAGE_MREG) ;
        else if (dest == TagExprAST::STORAGE_TREG) op += 1;
        O[0] = SHARED_OPRD(Opc, op, SMLoc(), SMLoc());
        if (isInc == TagExprAST::EXPR_APDLINC) {
          Flags.set(APPF);
          Flags.set(KPPF);
        }
        O.push_back(SHARED_OPRD(Imm, Flags.to_ulong(), SMLoc(), SMLoc()));
        Flags.reset();
        O.push_back(SHARED_OPRD(Slot, 10 + s->getID(), SMLoc(), SMLoc()));
      }
    } else if (t == TagExprAST::STORAGE_MREG) {
      if (s) {
        if (s->getID() == -1)
          errs() << "Uninitialized MReg variable for \"??? = MReg\".\n";  // this is an error
        unsigned op = MR0ToM;
        if (dest == TagExprAST::STORAGE_DM) op = MR3ToBIU;
        else if (dest == TagExprAST::STORAGE_MREG) op = MR0ToM;
        else if (dest == TagExprAST::STORAGE_TREG) op = MR0ToMACC;
        O[0] = SHARED_OPRD(Opc, op, SMLoc(), SMLoc());
        O.push_back(SHARED_OPRD(Reg, MMPULiteReg::M0, SMLoc(), SMLoc()));
        O.push_back(SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc()));
        // MRnToXX needs WF/WX flag
        O.push_back(SHARED_OPRD(Reg, MMPULiteReg::WF0, SMLoc(), SMLoc()));
        O.push_back(SHARED_OPRD(Slot, dest == TagExprAST::STORAGE_DM ? 3 : 0,
                                SMLoc(), SMLoc()));
        SrcStack.push_back(s->getID());
      }
    } else if (t == TagExprAST::STORAGE_MACREG) {
      if (s) {
        if (s->getID() == -1)
          errs() << "Uninitialized MAC variable for \"??? = MAC\".\n";
        unsigned op = IMRToBIU;
        if (dest == TagExprAST::STORAGE_DM) ;
        else if (dest == TagExprAST::STORAGE_MREG) op += 1;
        else if (dest == TagExprAST::STORAGE_TREG) op += 2;
        O[0] = SHARED_OPRD(Opc, op, SMLoc(), SMLoc());
        O.push_back(SHARED_OPRD(Reg, MMPULiteReg::MR, SMLoc(), SMLoc()));
        O.push_back(SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc()));
        O.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc())); //flags
        O.push_back(SHARED_OPRD(Slot, 13, SMLoc(), SMLoc()));
        SrcStack.push_back(s->getID());
      }
    } else {
      errs() << "Use expression : \"??? = TReg/KReg\" is illegal\n";
    }
    return;
  } else { // needTemp
    if (t == TagExprAST::STORAGE_DM) {
      /* BIU load is required */
      tempT = AllocateVReg(TagExprAST::STORAGE_TREG);
      if (s) {
        if (s->getID() == -1) s->Allocate(BIUID++);
        LoadO.push_back(SHARED_OPRD(Opc, BIU0LdToMACC + s->getID() * dist,
                                    SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::IALU, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc())); // IPath
        Slot = 10 + s->getID();
      }
    } else if (t == TagExprAST::STORAGE_MREG) {
      /* MR inst is required */
      tempT = AllocateVReg(TagExprAST::STORAGE_TREG);
      if (s) {
        if (s->getID() == -1)
          errs() << "Uninitialized MReg variable.\n";  // this is an error
                                                       // use MR0 as default
        LoadO.push_back(SHARED_OPRD(Opc, MR0ToMACC, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::IALU, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc())); // IPath
        // MRnToXX needs WF/WX flag
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::WF0, SMLoc(), SMLoc()));
        Slot = 0;
      }
    } else if (t == TagExprAST::STORAGE_TREG) {
      /* direct use TReg */
      if (s) {
        if (s->getID() == -1)
          assert("Uninitialized TReg variable.\n"); // this is an error
      }
      if (isInc != TagExprAST::INVALIDTAG) {
        /* Expression: treg var[index] is found here. there are two possible
           usage:
           1. index is a classic integer variable, then this is a broadcast inst
              used for operations between vector and scalar.
           2. index is a treg variable, then this is a table searching inst
              used for table searching, shuffle or irregular broadcast.
         */
        tempT = AllocateVReg(TagExprAST::STORAGE_TREG);
        if (isInc == TagExprAST::EXPR_SUB)
          LoadO.push_back(SHARED_OPRD(Opc, SHU0IndTBOptToMACC, SMLoc(), SMLoc()));
        else if (isInc == TagExprAST::EXPR_ASSIGN) {
          if (Index && Index->getNext() && Index->getNext()->getNext() &&
              isa<ExprExprAST>(Index->getNext()->getNext())) {
            Index = dyn_cast<ExprExprAST>(Index->getNext()->getNext())->getExpr();
            if (Index && Index->getNext() && isa<TagExprAST>(Index->getNext()) &&
                dyn_cast<TagExprAST>(Index->getNext())->getTag() ==
                TagExprAST::EXPR_APDLINC)
              LoadO.push_back(SHARED_OPRD(Opc, SHU0IndTOptToMACC, SMLoc(), SMLoc()));
            else
              LoadO.push_back(SHARED_OPRD(Opc, SHU0IndTNoOptToMACC, SMLoc(), SMLoc()));
          }
        } else if (isInc == TagExprAST::EXPR_IDENT) {
          LoadO.push_back(SHARED_OPRD(Opc, SHU0IndTBNoOptToMACC, SMLoc(), SMLoc()));
        }
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::IALU, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc())); // IPath
        Slot = 4;
      }
    } else if (t == TagExprAST::STORAGE_MACREG) {
      /* Load from MAC Register, generate a Psuedo inst for it and wait
         for legalization */
      if (s) {
        if (s->getID() == -1)
          errs() << "Uninitialized MAC variable.\n";
        tempT = AllocateVReg(TagExprAST::STORAGE_MACREG);
        LoadO.push_back(SHARED_OPRD(Opc, IMRToMACC, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::IALU, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc()));
        LoadO.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc())); // IPath
        Slot = 7;
      }
    }
  }
  
  if (t != TagExprAST::STORAGE_TREG) {
    LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::NOC, SMLoc(), SMLoc()));
    if (t == TagExprAST::STORAGE_DM) {
      // flags
      if (isInc == TagExprAST::EXPR_APDLINC) {
        Flags.set(APPF);
        Flags.set(KPPF);
      }
      LoadO.push_back(SHARED_OPRD(Imm, Flags.to_ulong(), SMLoc(), SMLoc()));
      Flags.reset();
    } else if (t == TagExprAST::STORAGE_MREG) { // MReg Load
      LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::M0, SMLoc(), SMLoc()));
      LoadO.push_back(SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc()));
      SrcStack.push_back(s->getID());
    } else if (t == TagExprAST::STORAGE_MACREG) {
      LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::MR, SMLoc(), SMLoc()));
      LoadO.push_back(SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc()));
      SrcStack.push_back(s->getID());
    }
    LoadO.push_back(SHARED_OPRD(Slot, Slot, SMLoc(), SMLoc()));
    DestStack.push_back(tempT);
    addParsedInst(new MCParsedInst(LoadO));
  } else if (isInc != TagExprAST::INVALIDTAG) {
    unsigned op = CAST_TO_MMPU_OPRD(LoadO[0])->getOpc();
    LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::NOC, SMLoc(), SMLoc()));
    LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
    LoadO.push_back(SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc()));
    SrcStack.push_back(s->getID());
    if (op == SHU0IndTNoOptToMACC || op == SHU0IndTOptToMACC)
      LoadO.push_back(SHARED_OPRD(Reg, MMPULiteReg::TBW, SMLoc(), SMLoc()));
    if (op == SHU0IndTBOptToMACC || op == SHU0IndTOptToMACC)
      LoadO.push_back(SHARED_OPRD(Imm, 4, SMLoc(), SMLoc()));
    else
      LoadO.push_back(SHARED_OPRD(Imm, 0, SMLoc(), SMLoc()));
      
    LoadO.push_back(SHARED_OPRD(Slot, Slot, SMLoc(), SMLoc()));
    DestStack.push_back(tempT);
    addParsedInst(new MCParsedInst(LoadO));
  }
  
  O.push_back(SHARED_OPRD(Reg, MMPULiteReg::VT, SMLoc(), SMLoc()));
  if (t != TagExprAST::STORAGE_TREG || isInc != TagExprAST::INVALIDTAG)
    O.push_back(SHARED_OPRD(Imm, tempT, SMLoc(), SMLoc()));
  else
    O.push_back(SHARED_OPRD(Imm, s->getID(), SMLoc(), SMLoc()));
}

void APDLGen::Legalize(void) {
  SharedMMPUOprd O;
  MCLoopBlock *top;
  unsigned dest;
  MCLoopBlock *Org;
  MCLoopBlock *Back;
  std::vector<MCParsedInst *> LocalTerminals;
  Graph<MCParsedInst *> ForwardDAG, BackwardDAG;
  std::map<MCParsedInst *, uint64_t> SrcBuffed;
  
  if (APDLFunc) {
    APDLFunc->EliminateEmptyBlock();
    if (APDLFunc->getBlocks().size()) {
      for (unsigned i = 0; i < APDLFunc->getBlocks().size(); i++) {
        top = APDLFunc;
        APDLFunc = APDLFunc->getBlocks()[i];
        Legalize();
        APDLFunc = top;
      }
    } else if (APDLFunc->size()) {
      // Add a psuedo start vextor into DAG
      ForwardDAG.AddVextor(NULL);
      BackwardDAG.AddVextor(NULL);
      /* Add psuedo arcs between the psuedo start node and all other vextors.
         The weight is non-zero if there is any connection between vextors and
         global terminals. */
      LeafBlockInfo[APDLFunc].Block = APDLFunc;
      for (unsigned i = 0; i < APDLFunc->getInsts().size(); i++) {
        ForwardDAG.AddVextor(APDLFunc->getInsts()[i]);
        BackwardDAG.AddVextor(APDLFunc->getInsts()[i]);
        if (SrcTable.count(APDLFunc->getInsts()[i])) {
          uint64_t weight = 0;
          for (unsigned j = 0;
               j < SrcTable[APDLFunc->getInsts()[i]].size();
               j++) {
            uint64_t src = SrcTable[APDLFunc->getInsts()[i]][j];
            if (GlobalTerminals.count(VRegTable[src].producer)) {
              LeafBlockInfo[APDLFunc].Entry.push_back(src);
              if (weight < GlobalTerminals[VRegTable[src].producer])
                weight = GlobalTerminals[VRegTable[src].producer];
            }
            if (VRegTable[src].type != TagExprAST::STORAGE_TREG)
              SrcBuffed[APDLFunc->getInsts()[i]] = weight;
          }
          BackwardDAG.AddArc(APDLFunc->getInsts()[i], NULL, weight);
        }
      }
      
      /* In the first round, collect all terminal insts, build the DAG */
      for (unsigned i = 0; i < APDLFunc->getInsts().size(); i++) {
        O = CAST_TO_MMPU_OPRD(APDLFunc->getInsts()[i]->getOperand(0));
        dest = O->getOpc();
        
        if (hasDest(O->getOpc())) {
          uint64_t vr;
          if (hasTDest(O->getOpc())) {
            O = CAST_TO_MMPU_OPRD(APDLFunc->getInsts()[i]->getOperand(3));
            vr = O->getImm();
          } else if (hasMDest(O->getOpc())) {
            O = CAST_TO_MMPU_OPRD(APDLFunc->getInsts()[i]->getOperand(2));
            vr = O->getImm();
          } else {
            O = CAST_TO_MMPU_OPRD(APDLFunc->getInsts()[i]->getOperand(1));
            vr = O->getReg() - MMPULiteReg::BIU0;
          }
            
          if (VRegTable.count(vr)) {
            for (unsigned j = 0;
                 j < VRegTable[vr].consumers.size();
                 j++) {
              uint64_t Pos;
              if (APDLFunc->findInstPos(VRegTable[vr].consumers[j], Pos)) {
                if (VRegTable[vr].type != TagExprAST::STORAGE_MACREG) {
                  BackwardDAG.AddArc(VRegTable[vr].consumers[j],
                                     APDLFunc->getInsts()[i],
                                     MMPULiteScheduler::getLatency(dest));
                } else {
                  /* For MAC variable, the register accessing time is several
                     cycles later than the inst issuing time */
                  uint64_t Postpone = 0;
                  unsigned consumerdest =
                    CAST_TO_MMPU_OPRD(VRegTable[vr].consumers[j]->getOperand(0))
                      ->getOpc();
                  if (consumerdest == IMA || (consumerdest >= IMAToBIU &&
                                              consumerdest <= IMAToSHU))
                    Postpone = 5;
                  else if (consumerdest >= IMAcc && consumerdest <= IMAccToSHU)
                    Postpone = 1;
                  else if (consumerdest >= IMaC && consumerdest <= IMaCToSHU)
                    Postpone = 5;
                  BackwardDAG.AddArc(VRegTable[vr].consumers[j],
                                     APDLFunc->getInsts()[i],
                                     MMPULiteScheduler::getLatency(dest) - Postpone);
                }
              } else {
                LocalTerminals.push_back(APDLFunc->getInsts()[i]);
                break;
              }
            }
          } else errs() << "Legalize an unused VReg.\n";
        } else {
          LocalTerminals.push_back(APDLFunc->getInsts()[i]);
          continue;
        }
        
        // If this is a TReg assignment, it needs to fix the dest
        
        if (O->isImm() && VRegTable.count(O->getImm()) &&
            !VRegTable[O->getImm()].consumers.empty() &&
            VRegTable[O->getImm()].type == TagExprAST::STORAGE_TREG) {
          if (VRegTable[O->getImm()].consumers.size() > 1)
            errs() << "Warning: TReg is referred more than once.\n";
            
          O = CAST_TO_MMPU_OPRD(VRegTable[O->getImm()].consumers[0]->getOperand(0));
          if (O->getOpc() >= SHU0CombToBIU) {
            //delete APDLFunc->getInsts()[i]->getOperand(0);
            (*APDLFunc->getInsts()[i]->getOperands())[0] =
              SHARED_OPRD(Opc, dest + 1, SMLoc(), SMLoc());
          }
          if (O->getOpc() >= IALUBinToBIU && O->getOpc() <= IALUUryToSHU) ;
          else if (O->getOpc() >= FALUBinToBIU && O->getOpc() <= FALUUryToSHU) {
            //delete APDLFunc->getInsts()[i]->getOperand(1);
            (*APDLFunc->getInsts()[i]->getOperands())[1] =
              SHARED_OPRD(Reg, MMPULiteReg::FALU, SMLoc(), SMLoc());
          } else if (O->getOpc() >= FMA && O->getOpc() <= FMulToSHU) {
            //delete APDLFunc->getInsts()[i]->getOperand(1);
            (*APDLFunc->getInsts()[i]->getOperands())[1] =
              SHARED_OPRD(Reg, MMPULiteReg::FMAC, SMLoc(), SMLoc());
          } else if (O->getOpc() >= IMA && O->getOpc() <= IMulToSHU) {
            //delete APDLFunc->getInsts()[i]->getOperand(1);
            (*APDLFunc->getInsts()[i]->getOperands())[1] =
              SHARED_OPRD(Reg, MMPULiteReg::IMAC, SMLoc(), SMLoc());
          } else if (O->getOpc() >= SHU0CombToBIU && O->getOpc() <= SHU0Stop) {
            //delete APDLFunc->getInsts()[i]->getOperand(1);
            (*APDLFunc->getInsts()[i]->getOperands())[1] =
              SHARED_OPRD(Reg, MMPULiteReg::SHU0, SMLoc(), SMLoc());
            APDLFunc->getInsts()[i]->delOperand(4);  // delete IPath
          } else if (O->getOpc() >= SHU1CombToBIU && O->getOpc() <= SHU1Stop) {
            //delete APDLFunc->getInsts()[i]->getOperand(1);
            (*APDLFunc->getInsts()[i]->getOperands())[1] =
              SHARED_OPRD(Reg, MMPULiteReg::SHU1, SMLoc(), SMLoc());
            APDLFunc->getInsts()[i]->delOperand(4);  // delete IPath
          }
        }
      }
      
      // NOP Insertion
      
      Back = APDLFunc->DupThisBlock(0);
      Org = APDLFunc->DupThisBlock(0);
      APDLFunc->getInsts().clear();
      
      /* Now DAG are built for current block, and all terminals 
         are collected in LocalTerminals, while all possible entries are stored
         in GlobalTerminals. To insert NOPs correctly, the critical path in DAG
         should be emitted first. */
      MCParsedInst *p = NULL;
      
      std::stack<unsigned> sre;
      unsigned maxroutine;
      //uint64_t *order = ForwardDAG.TopologicalOrder(sre, maxroutine);
      int64_t *revorder = BackwardDAG.TopologicalOrder(sre, maxroutine);
      uint64_t length = revorder[maxroutine];
      while (APDLFunc->getInsts().size() <= length)
        APDLFunc->addParsedInst(NULL);
      for (unsigned i = 0; i <= Org->getInsts().size(); i++)
        revorder[i] = length - revorder[i];
      for (unsigned i = 0; i < Org->getInsts().size(); i++) {
        ForwardDAG.AddArc(NULL, Org->getInsts()[i], revorder[i + 1]);
        if (APDLFunc->getInsts()[revorder[i + 1]])
          APDLFunc->getInsts()[revorder[i + 1]]->append(Org->getInsts()[i]);
        else
          APDLFunc->addParsedInst(revorder[i + 1] + APDLFunc->getStart(),
                                  Org->getInsts()[i]);
      }
#if 0
      std::map<MCParsedInst *, MCParsedInst *> critical;
      if (DAG.Criticalpath(critical)) {
        MCParsedInst *Next = NULL;
        while (critical.count(Next)) {
          Org->delInst(critical[Next]);
          unsigned i = 0;
          while (++i < DAG.getArcWeight(Next, critical[Next]))
            APDLFunc->addParsedInst(NULL);
          APDLFunc->addParsedInst(critical[Next]);
          errs() << "C:" << Next << "->" << critical[Next] << "\n";
          Next = critical[Next];
        }
      } else errs() << "No critical path!\n";
      
      // Add non-critical vextors
      while (!Org->getInsts().empty()) {
        if (!p) p = Org->getInsts().front();
        uint64_t Pos = APDLFunc->size() - 1;//DAG.getArcWeight(NULL, p);
        uint64_t Base = 0;
        bool deterministic = true;
        /*if (SrcTable.count(p) && SrcTable[p].size()) {
          for (unsigned i = 0;
               i < SrcTable[p].size();
               i++) {
            if (VRegTable.count(SrcTable[p][i]) &&
                VRegTable[SrcTable[p][i]].producer) {
              if (!APDLFunc->findInstPos(VRegTable[SrcTable[p][i]].producer,
                                         Base)) {
                p = VRegTable[SrcTable[p][i]].producer;
                continue;
              } else {
                uint64_t Latency = MMPULiteScheduler::
                  getLatency(CAST_TO_MMPU_OPRD(
                               VRegTable[SrcTable[p][i]].producer
                                                         ->getOperand(0))
                                                         ->getOpc());
                if (Pos < Base + Latency)
                  Pos = Base + Latency;
              }
            } else errs() << "source operand is not found or has no producer\n";
          }
        } else Pos = APDLFunc->getInsts().size() - 1;*/
        if (DestTable.count(p) && DestTable[p].size()) {
          /* non-critical node doesn't have an exact location, so let it
             depend on the location of consumers of it's dest here. */
          for (unsigned i = 0; i < DestTable[p].size(); i++) {
            if (VRegTable.count(DestTable[p][i]) &&
                VRegTable[DestTable[p][i]].consumers.size()) {
              for (unsigned j = 0;
                   j < VRegTable[DestTable[p][i]].consumers.size();
                   j++) {
                MCParsedInst *consumer =
                  VRegTable[DestTable[p][i]].consumers[j];
                if (!APDLFunc->findInstPos(consumer, Base) &&
                    Org->findInstPos(consumer, Base)) {
                  p = consumer;
                  deterministic = false;
                  break;
                }
                uint64_t Latency = MMPULiteScheduler::
                getLatency(CAST_TO_MMPU_OPRD(p->getOperand(0))
                           ->getOpc());
                if (VRegTable[DestTable[p][i]].type !=
                    TagExprAST::STORAGE_MACREG) {
                  if (Pos > Base - Latency) Pos = Base - Latency;
                } else {
                  uint64_t Postpone = 0;
                  unsigned consumerdest = CAST_TO_MMPU_OPRD
                                          (consumer->getOperand(0))->getOpc();
                  if (consumerdest == IMA || (consumerdest >= IMAToBIU &&
                                              consumerdest <= IMAToSHU))
                    Postpone = 5;
                  else if (consumerdest >= IMAcc && consumerdest <= IMAccToSHU)
                    Postpone = 1;
                  else if (consumerdest >= IMaC && consumerdest <= IMaCToSHU)
                    Postpone = 5;
                  if (Pos > Base + Postpone - Latency)
                    Pos = Base + Postpone - Latency;
                }
              }
            } else errs() << "dest operand is not found or has no consumer\n";
            if (!deterministic) break;
          }
        }
        if (deterministic) {
          if (APDLFunc->getInsts()[Pos]) APDLFunc->getInsts()[Pos]->append(p);
          else APDLFunc->addParsedInst(Pos + APDLFunc->getStart(), p);
          Org->delInst(p);
          p = NULL;
        }
      }
      delete Org;
#endif
      /* After the first round of legalization, there might be some slot
         collisions which reside in MCParsedInst chains. */
      errs() << "Solve collision\n";
      for (unsigned i = 0; i < APDLFunc->size(); i++) {
        MCParsedInst *Head = APDLFunc->getInsts()[i];
        MCParsedInst *q = Head, *LastCol;
        if (Head) p = Head->getNext();
        else p = NULL;
        while (p) {
          int64_t weight = 0;
          while (p != q) {
            if (CheckCollision(q, p)) {
              LastCol = q;
              weight++;
            }
            q = q->getNext();
          }
          if (weight != 0) {
            SmallVector<SharedOperand, 8> n;
            n.push_back(SHARED_OPRD(Opc, NOP, SMLoc(), SMLoc()));
            MCParsedInst *MI = new MCParsedInst(n);
            BackwardDAG.InsertVextor(MI, p, 1);
            BackwardDAG.AddArc(MI, LastCol, 0);
          }
          p = p->getNext();
          q = Head;
        }
      }
      
      Org = Back->DupThisBlock(0);
      for (unsigned i = 0; i < Org->size(); i++)
        Org->getInsts()[i]->setNext(NULL);
      
      APDLFunc->getInsts().clear();
      //uint64_t *order = ForwardDAG.TopologicalOrder(sre, maxroutine);
      revorder = BackwardDAG.TopologicalOrder(sre, maxroutine);
      length = revorder[maxroutine];
      while (APDLFunc->getInsts().size() <= length)
        APDLFunc->addParsedInst(NULL);
      for (unsigned i = 0; i <= Org->getInsts().size(); i++)
        revorder[i] = length - revorder[i];
      for (unsigned i = 0; i < Org->getInsts().size(); i++) {
        if (APDLFunc->getInsts()[revorder[i + 1]])
          APDLFunc->getInsts()[revorder[i + 1]]->append(Org->getInsts()[i]);
        else
          APDLFunc->addParsedInst(revorder[i + 1] + APDLFunc->getStart(),
                                  Org->getInsts()[i]);
      }
      /*
      int64_t *order = ForwardDAG.TopologicalOrder(sre, maxroutine);
      while (APDLFunc->getInsts().size() <= uint64_t(order[maxroutine]))
        APDLFunc->addParsedInst(NULL);
      for (unsigned i = 0; i < Org->getInsts().size(); i++) {
        if (APDLFunc->getInsts()[order[i + 1]])
          APDLFunc->getInsts()[order[i + 1]]->append(Org->getInsts()[i]);
        else
          APDLFunc->addParsedInst(order[i + 1] + APDLFunc->getStart(),
                                  Org->getInsts()[i]);
      }
       */
#if 0
      critical.clear();
      if (DAG.Criticalpath(critical)) {
        MCParsedInst *Next = NULL;
        while (critical.count(Next)) {
          Org->delInst(critical[Next]);
          unsigned i = 0;
          while (++i < DAG.getArcWeight(Next, critical[Next]))
            APDLFunc->addParsedInst(NULL);
          APDLFunc->addParsedInst(critical[Next]);
          Next = critical[Next];
        }
      } else errs() << "No critical path!\n";
      
      // Add non-critical vextors
      while (!Org->getInsts().empty()) {
        if (!p) p = Org->getInsts().front();
        uint64_t Pos = APDLFunc->size() - 1;//DAG.getArcWeight(NULL, p);
        uint64_t Base = 0;
        bool deterministic = true;
        if (DestTable.count(p) && DestTable[p].size()) {
          for (unsigned i = 0; i < DestTable[p].size(); i++) {
            if (VRegTable.count(DestTable[p][i]) &&
                VRegTable[DestTable[p][i]].consumers.size()) {
              for (unsigned j = 0;
                   j < VRegTable[DestTable[p][i]].consumers.size();
                   j++) {
                MCParsedInst *consumer =
                  VRegTable[DestTable[p][i]].consumers[j];
                if (!APDLFunc->findInstPos(consumer, Base) &&
                    Org->findInstPos(consumer, Base)) {
                  p = VRegTable[DestTable[p][i]].consumers[j];
                  deterministic = false;
                  break;
                }
                uint64_t Latency = MMPULiteScheduler::
                getLatency(CAST_TO_MMPU_OPRD(p->getOperand(0))
                           ->getOpc());
                if (Pos > Base - Latency) Pos = Base - Latency;
              }
            } else errs() << "dest operand is not found or has no consumer\n";
            if (!deterministic) break;
          }
        }
        if (deterministic) {
          if (APDLFunc->getInsts()[Pos]) APDLFunc->getInsts()[Pos]->append(p);
          else APDLFunc->addParsedInst(Pos + APDLFunc->getStart(), p);
          Org->delInst(p);
          p = NULL;
        }
      }
      delete Org;
      delete Back;
#endif

      // All Insts have been legalized, update the GlobalTerminals
      uint64_t Latency = APDLFunc->getInsts().size();
      std::map<MCParsedInst *, uint64_t>::iterator iter;
      for (iter = GlobalTerminals.begin();
           iter != GlobalTerminals.end();
           iter++)
        if (iter->second < Latency) iter->second = 0;
        else iter->second -= Latency;
      for (unsigned i = 0; i < LocalTerminals.size(); i++) {
        O = CAST_TO_MMPU_OPRD(LocalTerminals[i]->getOperand(0));
        dest = O->getOpc();
      
        if (hasDest(O->getOpc())) {
          uint64_t Pos = 0;
          APDLFunc->findInstPos(LocalTerminals[i], Pos);
          if (MMPULiteScheduler::getLatency(dest) >= (Latency - 1 - Pos))
            GlobalTerminals[LocalTerminals[i]] =
              MMPULiteScheduler::getLatency(dest) - (Latency - 1 - Pos);
          else
            GlobalTerminals[LocalTerminals[i]] = 0;
          uint64_t vr;
          if (hasTDest(O->getOpc())) {
            O = CAST_TO_MMPU_OPRD
                (LocalTerminals[i]->getOperand(3));
            vr = O->getImm();
          } else if (hasMDest(O->getOpc())) {
            O = CAST_TO_MMPU_OPRD
                (LocalTerminals[i]->getOperand(2));
            vr = O->getImm();
          } else {
            O = CAST_TO_MMPU_OPRD
                (LocalTerminals[i]->getOperand(1));
            vr = O->getReg() - MMPULiteReg::BIU0;
          }
          LeafBlockInfo[APDLFunc].Terminal.push_back(vr);
        }
      }
    }
    /* FIXME: Loop is not properly dealed with yet. If there is any variable
       iterated between loops, it shall be announced as a PHY node */
    APDLFunc->RecalStart(0);
  } // end of APDLFunc
}
  
bool APDLGen::hasDest(unsigned Opc) const {
  unsigned index = 0;
  if (Opc >= BIU0KG) {
    index = Opc - BIU0KG;
    if (MMPULiteScheduler::ResUsageMap[index] &
        (MMPULiteScheduler::R_SHUT | MMPULiteScheduler::R_MACCT |
         MMPULiteScheduler::R_MW | MMPULiteScheduler::R_BIUW |
         (1 << MMPULiteScheduler::IMRW)))
      return true;
    else return false;
  }
  return false;
}
  
bool APDLGen::hasTDest(unsigned Opc) const {
  unsigned index = 0;
  if (Opc >= BIU0KG) {
    index = Opc - BIU0KG;
    if (MMPULiteScheduler::ResUsageMap[index] &
        (MMPULiteScheduler::R_SHUT | MMPULiteScheduler::R_MACCT))
      return true;
    else return false;
  }
  return false;
}
  
bool APDLGen::hasMDest(unsigned Opc) const {
  unsigned index = 0;
  if (Opc >= BIU0KG) {
    index = Opc - BIU0KG;
    if (MMPULiteScheduler::ResUsageMap[index] &
        (MMPULiteScheduler::R_MW | (1 << MMPULiteScheduler::IMRW)))
      return true;
    else return false;
  }
  return false;
}
  
bool APDLGen::UseIPath(unsigned Opc) const {
  unsigned index = 0;
  if (Opc >= BIU0KG) {
    index = Opc - BIU0KG;
    if (MMPULiteScheduler::ResUsageMap[index] & MMPULiteScheduler::R_IPATH)
      return true;
    else return false;
  }
  return false;
}

bool APDLGen::CheckCollision(MCParsedInst *I1, MCParsedInst *I2) const {
  if (!I1 || !I2) return false;
  unsigned Slot1 = CAST_TO_MMPU_OPRD
  (I1->getOperand(I1->size() - 1))->getSlot();
  unsigned Slot2 = CAST_TO_MMPU_OPRD
  (I2->getOperand(I2->size() - 1))->getSlot();
  return Slot1 == Slot2;
}

void APDLGen::RegAllocation(void) {
  // Initialize all register pools
  
  typedef std::vector<struct lifespan> history;
  history IALUTRF[100];
  history FALUTRF[100];
  history IMACTRF[100];
  history FMACTRF[100];
  history SHU0TRF[100];
  history SHU1TRF[100];
  history MRF[128];
  
  history *RegFiles[7] = {IALUTRF, FALUTRF, IMACTRF, FMACTRF,
                          SHU0TRF, SHU1TRF, MRF};
  
  int32_t regclass = -1;
  uint64_t birth = 0, retire = 0, loop = 1, loopsize = 0;
  uint64_t latency = 0, pos = 0;
  unsigned poolsize = 0;
  
  for (uint64_t i = 3; i < VRegTable.size(); i++) {
    // Calculate the lifespan of this virtual register
    if (VRegTable[i].type == TagExprAST::STORAGE_MACREG) {
      for (unsigned k = 0; k < VRegTable[i].consumers.size(); k++)
        for (unsigned j = 0; j < VRegTable[i].consumers[k]->getOperands()->size(); j++) {
          if (CAST_TO_MMPU_OPRD
              ((*VRegTable[i].consumers[k]->getOperands())[j])->isReg() &&
              CAST_TO_MMPU_OPRD
              ((*VRegTable[i].consumers[k]->getOperands())[j])->getReg() ==
              MMPULiteReg::MR) {
            VRegTable[i].consumers[k]->delOperand(j);
            VRegTable[i].consumers[k]->delOperand(j);
          }
        }
      if (VRegTable[i].producer) {
        for (unsigned j = 0; j < VRegTable[i].producer->getOperands()->size(); j++) {
          if (CAST_TO_MMPU_OPRD
              ((*VRegTable[i].producer->getOperands())[j])->isReg() &&
              CAST_TO_MMPU_OPRD
              ((*VRegTable[i].producer->getOperands())[j])->getReg() ==
              MMPULiteReg::MR) {
            VRegTable[i].producer->delOperand(j);
            VRegTable[i].producer->delOperand(j);
          }
        }
      }
      continue;
    }
    if (VRegTable[i].producer &&
        !VRegTable[i].consumers.empty()) {
      VRegTable[i].producer->getParent()->findInstPos(VRegTable[i].producer,
                                                      pos);
      latency = MMPULiteScheduler::
                getLatency(CAST_TO_MMPU_OPRD
                           (VRegTable[i].producer->getOperand(0))->getOpc());
      birth = VRegTable[i].producer->getParent()->getStart() + pos + latency;
      retire = 0;
      for (unsigned j = 0; j < VRegTable[i].consumers.size(); j++) {
        MCParsedInst *consumer = VRegTable[i].consumers[j];
        consumer->getParent()->findInstPos(VRegTable[i].consumers[j], pos);
        if (retire < consumer->getParent()->getStart() + pos)
          retire = consumer->getParent()->getStart() + pos;
        /* Calculate the retire time is very complex, it must meet the following
           requirements:
           1. the top Loop;
           2. block that doesn't include the producer;
          */
        MCLoopBlock *Ref = consumer->getParent();
        MCLoopBlock *Res = NULL;
        while (Ref) {
          if (Ref == VRegTable[i].producer->getParent()) break;
          if (Ref->getType() == Loop) {
            if (Ref->getKI() == VRegTable[i].producer->getParent()->getKI())
              // they are sub loops splitted from the same loop
              break;
            Res = Ref;
          }
          Ref = Ref->getParent();
        }
        if (Res) retire = Res->getStart() + Res->size(); // FIXME: reserved too much
      }
      if (VRegTable[i].producer->getParent()->getType() == Loop) {
        loop = LoopInfoMap[VRegTable[i].producer->getParent()->getKI()].OrigSize /
               LoopInfoMap[VRegTable[i].producer->getParent()->getKI()].SplitSize;
        loopsize = LoopInfoMap[VRegTable[i].producer->getParent()->getKI()].SplitSize;
      }
      if (retire == 0) errs() << "Consumer is not found.\n";
    } else errs() << "VReg was allocated but is never used.\n";
    
    // Get the register class of this virtual register
    if (VRegTable[i].type == TagExprAST::STORAGE_MREG) {
      regclass = 6;
    } else if (VRegTable[i].type == TagExprAST::STORAGE_TREG &&
               VRegTable[i].producer) {
      switch (CAST_TO_MMPU_OPRD(VRegTable[i].producer->getOperand(1))
                ->getReg()) {
      case MMPULiteReg::IALU:
        regclass = 0;
        break;
      case MMPULiteReg::FALU:
        regclass = 1;
        break;
      case MMPULiteReg::IMAC:
        regclass = 2;
        break;
      case MMPULiteReg::FMAC:
        regclass = 3;
        break;
      case MMPULiteReg::SHU0:
        regclass = 4;
        break;
      case MMPULiteReg::SHU1:
        regclass = 5;
        break;
      default:
        regclass = -1;
        break;
      }
    }
    if (regclass == -1) errs() << "Unknown register class.\n";
    if (regclass == 6) poolsize = 128;
    else poolsize = 4;
    unsigned j;
    for (j = 0; j < poolsize; j++) {
      bool allocatable = true;
      for (unsigned k = 0; k < RegFiles[regclass][j].size(); k++)
        for (unsigned newloop = 0; newloop < loop; newloop++) {
          for (unsigned testloop = 0;
               testloop < RegFiles[regclass][j][k].loop;
               testloop++) {
            if (((birth + newloop * loopsize >=
                  RegFiles[regclass][j][k].birth +
                  testloop * RegFiles[regclass][j][k].loopsize) &&
                 (birth + newloop * loopsize <=
                  RegFiles[regclass][j][k].retire +
                  testloop * RegFiles[regclass][j][k].loopsize)) ||
                ((retire + newloop * loopsize >=
                  RegFiles[regclass][j][k].birth +
                  testloop * RegFiles[regclass][j][k].loopsize) &&
                 (retire + newloop * loopsize <=
                  RegFiles[regclass][j][k].retire +
                  testloop * RegFiles[regclass][j][k].loopsize))) {
              allocatable = false;
              break;
            }
          }
          if (!allocatable) break;
        }
      if (!allocatable) continue;
      RegFiles[regclass][j].push_back(*new struct lifespan);
      RegFiles[regclass][j].back().birth = birth;
      RegFiles[regclass][j].back().retire = retire;
      RegFiles[regclass][j].back().loop = loop;
      RegFiles[regclass][j].back().loopsize = loopsize;
      if (regclass == 6) {
        //delete VRegTable[i].producer->getOperand(1);
        (*VRegTable[i].producer->getOperands())[1] =
          SHARED_OPRD(Reg, MMPULiteReg::M0 + j, SMLoc(), SMLoc());
        VRegTable[i].producer->delOperand(2);
        for (unsigned k = 0; k < VRegTable[i].consumers.size(); k++) {
          for (unsigned l = 0;
               l < VRegTable[i].consumers[k]->getOperands()->size();
               l++) {
            if ((*VRegTable[i].consumers[k]->getOperands())[l]->isReg() &&
                (*VRegTable[i].consumers[k]->getOperands())[l]->getReg()
                 == MMPULiteReg::M0) {
              if (l + 1 < VRegTable[i].consumers[k]->getOperands()->size() &&
                  (*VRegTable[i].consumers[k]->getOperands())[l + 1]->isImm() &&
                  CAST_TO_MMPU_OPRD
                  ((*VRegTable[i].consumers[k]->getOperands())[l + 1])->getImm() ==
                  int64_t(i)) {
                //delete (*VRegTable[i].consumers[k]->getOperands())[l];
                (*VRegTable[i].consumers[k]->getOperands())[l] =
                  SHARED_OPRD(Reg, MMPULiteReg::M0 + j, SMLoc(), SMLoc());
                VRegTable[i].consumers[k]->delOperand(l + 1);
              }
            }
          }
        }
      } else {
        //delete VRegTable[i].producer->getOperand(2);
        (*VRegTable[i].producer->getOperands())[2] =
          SHARED_OPRD(Reg, MMPULiteReg::T0 + j, SMLoc(), SMLoc());
        VRegTable[i].producer->delOperand(3);
        for (unsigned k = 0; k < VRegTable[i].consumers.size(); k++) {
          for (unsigned l = 0;
               l < VRegTable[i].consumers[k]->getOperands()->size();
               l++) {
            if ((*VRegTable[i].consumers[k]->getOperands())[l]->isReg() &&
                (*VRegTable[i].consumers[k]->getOperands())[l]->getReg()
                == MMPULiteReg::VT) {
              if (l + 1 < VRegTable[i].consumers[k]->getOperands()->size() &&
                  (*VRegTable[i].consumers[k]->getOperands())[l + 1]->isImm() &&
                  CAST_TO_MMPU_OPRD
                  ((*VRegTable[i].consumers[k]->getOperands())[l + 1])->getImm() ==
                  int64_t(i)) {
                //delete (*VRegTable[i].consumers[k]->getOperands())[l];
                (*VRegTable[i].consumers[k]->getOperands())[l] =
                  SHARED_OPRD(Reg, MMPULiteReg::T0 + j, SMLoc(), SMLoc());
                VRegTable[i].consumers[k]->delOperand(l + 1);
              }
            }
          }
        }
      }
      
      break; // successfully allocated, stop searching physical registers
    }
    if (j == poolsize) errs() << "Regs " << regclass << " out of use.\n";
    errs() << regclass << " RA " << i << ": " << birth << ":" << retire << ":"
           << loop << ":" << loopsize << "\n";
    // FIXME: whatif TReg are out of use?
  }
}
  
void APDLGen::Emit(void) {
  MMPULiteInstPrinter* printer = new MMPULiteInstPrinter();
  MCInst *MI = NULL;
  std::map<MCLoopBlock *, uint64_t> HMacroMap;
  uint64_t HMacroID = 0;
  while (!HMacros.empty()) {
    if (HMacroMap.count(HMacros.back()) == 0)
      HMacroMap[HMacros.back()] = HMacroID++;
    *O << ".hmacro hm_" << HMacroMap[HMacros.back()] << "\n";
    if (HMacros.back()->getBlocks().size()) {
      uint64_t addr = HMacros.back()->getStart();
      unsigned i = 0;
      if (HMacros.back()->getType() == Loop) {
        *O << "LPTO (1f) @(KI" << HMacros.back()->getKI();
        if (HMacros.back()->getCount() != 0)
          *O << HMacros.back()->getCount();
        *O << ") ";
      }
      while (i < HMacros.back()->getBlocks().size()) {
        std::string split = "";
        for (unsigned j = 0; j < HMacros.back()->getBlocks().size(); j++) {
          uint64_t fixstart = HMacros.back()->getBlocks()[j]->getStart();
          if (HMacros.back()->getType() == Loop &&
              HMacros.back()->getBlocks()[j]->getType() != Loop) {
            errs() << "T: " << HMacros.back()->getBlocks()[j]->getType() << "\n";
            fixstart++;
          }
            /*else if (HMacros.back()->getType() != Loop &&
                     HMacros.back()->getBlocks()[j]->getType() == Loop &&
                     fixstart != 0)
              fixstart--;
            else if (HMacros.back()->getType() != Loop &&
                     HMacros.back()->getBlocks()[j]->getType() != Loop &&
                     fixstart == 0)
              fixstart++;*/
          if (addr == HMacros.back()->getStart() &&
              HMacros.back()->getType() == Loop)
            split = "||";
          errs() << "S: " << addr << "|" << HMacros.back()->getStart() << "|" << fixstart << "\n";
          if (fixstart == addr) {
            i++;
            HMacroMap[HMacros.back()->getBlocks()[j]] = HMacroID++;
            *O << split << " hm_"
               << HMacroMap[HMacros.back()->getBlocks()[j]];
            if (HMacros.back()->getType() == Loop) *O <<"()";
            *O << " ";
            split = "||";
          }
        }
        if (split == "") *O << "NOP;\n";
        else *O << ";\n";
        addr++;
      }
      if (HMacros.back()->getType() == Loop) *O << "1:\n";
    } else {
      if (HMacros.back()->getType() == Loop) {
        *O << "LPTO (1f) @(KI" << HMacros.back()->getKI();
        if (HMacros.back()->getCount() != 0)
          *O << HMacros.back()->getCount();
        *O << ");\n";
      }
      for (unsigned i = 0; i < HMacros.back()->getInsts().size(); i++) {
        MI = Translate(HMacros.back()->getInsts()[i]);
        if (MI) printer->printInst(MI, *O, "");
        *O << "\n";
      }
      if (HMacros.back()->getType() == Loop) *O << "1:\n";
    }
    *O << ".endhm\n\n";
    HMacros.pop_back();
  }
  delete printer;
}
  
MCInst *APDLGen::Translate(MCParsedInst *PInst) {
  MCInst *Inst = new MCInst;
  MCInst *CurInst = Inst, *NewInst;
  SharedMMPUOprd op;
  MCOperand MO;
  
  while (PInst) {
    SharedOperandVector *ops = PInst->getOperands();
    for(unsigned i=0; ops && i < ops->size(); i++) {
      op = CAST_TO_MMPU_OPRD((*ops)[i]);
      switch(op->getKind()) {
      default:
        return NULL;
          
      case AsmOpcode:
        if (op->getOpc() == MMPULite::NOP) break;
        NewInst = new MCInst;
        MO = MCOperand::CreateInst(NewInst);
        CurInst->addOperand(MO);
        CurInst = NewInst;
        CurInst->setOpcode(op->getOpc());
        CurInst->setLoc(op->getStartLoc());
        Inst->addOperand(MO); // There is a redundant MCOperand for the first MCInst.
        break;
          
      case AsmRegister:
        MO = MCOperand::CreateReg(op->getReg());
        CurInst->addOperand(MO);
        Inst->addOperand(MO);
        break;
          
      case AsmImmediate:
        MO = MCOperand::CreateImm(op->getImm());
        CurInst->addOperand(MO);
        Inst->addOperand(MO);
        break;
          
      case AsmExpression:
        MO = MCOperand::CreateExpr(op->getExpr());
        CurInst->addOperand(MO);
        Inst->addOperand(MO);
        break;
          
      case AsmHMacro:
        break;
          
      case AsmSlot:
        break;
      }
    }
    PInst = PInst->getNext();
  }
  if (Inst->getNumOperands() == 0) {
    NewInst = new MCInst();
    NewInst->setOpcode(MMPULite::NOP);
    Inst->addOperand(MCOperand::CreateInst(NewInst));
    CurInst = NewInst;
  }
  return Inst;
}
  
void APDLGen::GlobalSchedule(void) {
  std::map<MCLoopBlock *, struct BlockInfo>::iterator iter;
  std::vector<MCLoopBlock *> GlobalEntry;
  
  // FIXME: fixup Loop and MAC inst
  
  for (iter = LeafBlockInfo.begin(); iter != LeafBlockInfo.end(); iter++)
    HMacros.push_back(iter->second.Block);
  
  if (OptLevel == 0) return;
  // Add a psuedo start vextor into DAG
  GlobalDAG.AddVextor(NULL);
  
  for (iter = LeafBlockInfo.begin(); iter != LeafBlockInfo.end(); iter++) {
    GlobalDAG.AddVextor(iter->second.Block);
    if (iter->second.Entry.empty())
      GlobalEntry.push_back(iter->first);
  }
  
  /* Add psuedo arcs between the psuedo start node and all other vextors.
   The weight is non-zero if there is any connection between vextors and
   global terminals. */
  for (unsigned i = 0; i < GlobalEntry.size(); i++)
    GlobalDAG.AddArc(NULL, GlobalEntry[i], 0);
  
  for (unsigned i = 0; i < GlobalEntry.size(); i++) {
    struct BlockInfo &p = LeafBlockInfo[GlobalEntry[i]];
    for (unsigned j = 0; j < p.Terminal.size(); j++) {
      if (VRegTable.count(p.Terminal[j])) {
        MCParsedInst *producer = VRegTable[p.Terminal[j]].producer;
        uint64_t Latency = MMPULiteScheduler::getLatency
        (CAST_TO_MMPU_OPRD(producer->getOperand(0))->getOpc());
        uint64_t PosT = 0, PosE = 0;
        producer->getParent()->findInstPos(producer, PosT);
        for (unsigned k = 0;
             k < VRegTable[p.Terminal[j]].consumers.size();
             k++) {
          MCParsedInst *consumer = VRegTable[p.Terminal[j]].consumers[k];
          if (consumer && consumer->getParent() &&
              consumer->getParent() != producer->getParent() && // This an MReg variable
              LeafBlockInfo.count(consumer->getParent()) &&
              consumer->getParent()->findInstPos(consumer, PosE)) {
            // find an Arc, calculate its weight
            errs() << PosT << ":" << Latency << ":" << PosE << "\n";
            if (PosT + Latency >= PosE) {
              if (GlobalDAG.getArcWeight(consumer->getParent(),
                                         producer->getParent()) ||
                  GlobalDAG.getArcWeight(producer->getParent(),
                                         consumer->getParent()) + PosE <
                  PosT + Latency)
                GlobalDAG.DelArc(consumer->getParent(), producer->getParent());
                GlobalDAG.AddArc(producer->getParent(), consumer->getParent(),
                                 PosT + Latency - PosE);
            } else {
              GlobalDAG.AddArc(consumer->getParent(), producer->getParent(), 
                               PosE - PosT - Latency);
            }
            // delete the entry
            std::vector<uint64_t>::iterator deliter =
              LeafBlockInfo[consumer->getParent()].Entry.begin();
            while (deliter != LeafBlockInfo[consumer->getParent()].Entry.end() &&
                   *deliter != p.Terminal[j]) deliter++;
            if (deliter == LeafBlockInfo[consumer->getParent()].Entry.end())
              errs() << "cannot find an entry for this terminal: "
                     << p.Terminal[j] << "\n";
            else
              LeafBlockInfo[consumer->getParent()].Entry.erase(deliter);
            if (LeafBlockInfo[consumer->getParent()].Entry.empty())
              GlobalEntry.push_back(consumer->getParent());
          } else if (consumer && consumer->getParent() &&
                     consumer->getParent() != producer->getParent())
            errs() << "Spurious entry of the block, consumer has no parent.\n";
        }
      } else errs() << "Spurious entry of the block, "
                       "terminal cannot be find in VReg table.\n";
    }
  }
  
  std::map<MCLoopBlock *, MCLoopBlock *> critical;
  
  std::vector<MCLoopBlock *> UnitHMacros;
  
  if (GlobalDAG.Criticalpath(critical)) {
    MCLoopBlock *Next = NULL;
    uint64_t start = 0;
    while (critical.count(Next)) {
      LeafBlockInfo[critical[Next]].Scheduled = true;
      start += GlobalDAG.getArcWeight(Next, critical[Next]);
      critical[Next]->setStart(start);
      UnitHMacros.push_back(critical[Next]);
      Next = critical[Next];
    }
  } else errs() << "No critical path!\n";
  
  while (1) {
    for (iter = LeafBlockInfo.begin(); iter != LeafBlockInfo.end(); iter++)
      if (!iter->second.Scheduled) break;
    if (iter == LeafBlockInfo.end()) break;
    else do {
      uint64_t start = 0;
      unsigned i;
      for (i = 0; i < iter->second.Entry.size(); i++) {
        MCLoopBlock *pp;
        if (VRegTable.count(iter->second.Entry[i]) &&
            VRegTable[iter->second.Entry[i]].producer &&
            (pp = VRegTable[iter->second.Entry[i]].producer->getParent())) {
          unsigned j;
          for (j = 0; j < UnitHMacros.size(); j++) {
            if (UnitHMacros[j] == pp) {
              if (start < pp->getStart() +
                          GlobalDAG.getArcWeight(pp, iter->first)) 
                start = pp->getStart() +
                        GlobalDAG.getArcWeight(pp, iter->first);
              break;
            }
          }
          if (j == UnitHMacros.size()) break;
        }
      }
      if (i == iter->second.Entry.size()) {
        iter->second.Scheduled = true;
        iter->first->setStart(start);
        UnitHMacros.push_back(iter->first);
      }
    } while (++iter != LeafBlockInfo.end());
  }
  
  HMacros = UnitHMacros;
}

void APDLGen::SoftPipe(void) {
  if (OptLevel <= 1) return;
  /* Unrolling the inner loops */
  uint64_t relax = OptLevel - 2;
  std::vector<MCLoopBlock *> AfterUnroll;
  for (unsigned i = 0; i < HMacros.size(); i++) {
    if (HMacros[i]->getType() == Loop) {
      uint64_t nonbubbles;
      EstimatePipelineUsage(HMacros[i], nonbubbles);
      if (nonbubbles != 0) {
        MCLoopBlock *P = HMacros[i]->getParent();
        // Pad the loop with Nops to match times of non-bubbles
        if (nonbubbles == HMacros[i]->size()) {
          AfterUnroll.push_back(HMacros[i]);
          continue;
        }
        nonbubbles = nonbubbles + relax;
        while (HMacros[i]->size() % nonbubbles != 0) {
          HMacros[i]->addParsedInst(NULL);
          EstimatePipelineUsage(HMacros[i], nonbubbles);
          nonbubbles = nonbubbles + relax;
        }
        /* Split the loop into (HMacros[i]->size() % nonbubbles) of sub loops,
         each of which is in the size of non-bubbles. */
        LoopInfoMap[HMacros[i]->getKI()].KReg = HMacros[i]->getKI();
        LoopInfoMap[HMacros[i]->getKI()].OrigSize = HMacros[i]->size();
        LoopInfoMap[HMacros[i]->getKI()].SplitSize = nonbubbles;
        unsigned numofsubs = HMacros[i]->size() / nonbubbles;
        errs() << "Info: Loop KI" << HMacros[i]->getKI() << " (size is "
               << HMacros[i]->size() << ") is splitted into size of "
               << nonbubbles << "\n";
        for (unsigned j = 0; j < numofsubs; j++) {
          MCLoopBlock *NewSubLoop =
          HMacros[i]->DupThisBlock(HMacros[i]->getStart() + j * nonbubbles);
          errs() << "Debug: " << HMacros[i]->getStart() + j * nonbubbles << "\n";
          NewSubLoop->setParent(P);
          for (unsigned k = 0; k < nonbubbles; k++)
            HMacros[i]->getInsts().erase(HMacros[i]->getInsts().begin());
          bool AllNopLoop = true;
          for (unsigned k = 0; k < nonbubbles; k++)
            if (NewSubLoop->getInsts()[k]) {
              AllNopLoop = false;
              break;
            }
          for (unsigned k = 0; k < HMacros[i]->size(); k++)
            NewSubLoop->getInsts().pop_back();
          if (!AllNopLoop) {
            AfterUnroll.push_back(NewSubLoop);
            P->addSubBlock(NewSubLoop);
          } else delete NewSubLoop;
        }
        std::vector<MCLoopBlock *> Reorder = P->getBlocks();
        P->getBlocks().clear();
        uint64_t index = P->getStart();
        while (!Reorder.empty()) {
          uint64_t nextindex = 0;
          std::vector<MCLoopBlock *>::iterator iter;
          for (iter = Reorder.begin(); iter != Reorder.end(); iter++) {
            if ((*iter) == HMacros[i]) {
              delete *iter;
              Reorder.erase(iter);
              break;
            }
          }
          for (iter = Reorder.begin(); iter != Reorder.end(); ) {
            if (nextindex == 0) nextindex = (*iter)->getStart();
            else if ((*iter)->getStart() != index &&
                     nextindex > (*iter)->getStart())
              nextindex = (*iter)->getStart();
            if ((*iter)->getStart() == index) {
              P->addSubBlock(*iter);
              Reorder.erase(iter);
            } else iter++;
          }
          index = nextindex;
        }
      }
    } else AfterUnroll.push_back(HMacros[i]);
  }
  
  HMacros = AfterUnroll;
}
  
void APDLGen::EstimatePipelineUsage(MCLoopBlock *Pipeline,
                                    uint64_t &Bubbles) const {
  Bubbles = 0;
  uint64_t Units[14] = {0};
  for (unsigned i = 0; i < Pipeline->size(); i++) {
    MCParsedInst *PInst = Pipeline->getInsts()[i];
    if (!PInst) {
      Units[13]++;
      continue;
    }
    while (PInst) {
      unsigned category = CAST_TO_MMPU_OPRD
                          (PInst->getOperand(PInst->size() - 1))->isSlot() ?
                          CAST_TO_MMPU_OPRD
                          (PInst->getOperand(PInst->size() - 1))->getSlot() : 13;
      Units[category]++;
      PInst = PInst->getNext();
    }
  }
  //unsigned critical_unit_id;
  for (unsigned i = 0; i < 13; i++) {
    if (Bubbles < Units[i]) {
      //critical_unit_id = i;
      Bubbles = Units[i];
    }
  }
}
  
void APDLGen::ResourceAllocation(void) {
  std::vector<lifespan> IPath[3];
  uint64_t latency, ocuppy, loop, loopsize; // Only is birth(ocuppy) used for IPath
  MCParsedInst *MPI;
  for (unsigned i = 0; i < HMacros.size(); i++) {
    if (!HMacros[i]->isNested()) {
      for (unsigned j = 0; j < HMacros[i]->size(); j++) {
        HMacros[i]->getParsedInst(HMacros[i]->getStart() + j, MPI);
        while (MPI) {
          unsigned op =
            CAST_TO_MMPU_OPRD(MPI->getOperand(0))->getOpc();
          if (UseIPath(op)) {
            latency = MMPULiteScheduler::getLatency(op, MMPULiteScheduler::I0);
            ocuppy = HMacros[i]->getStart() + j + latency;
            if (HMacros[i]->getType() == Loop) {
              loop = LoopInfoMap[HMacros[i]->getKI()].OrigSize /
                     LoopInfoMap[HMacros[i]->getKI()].SplitSize;
              loopsize = loop = LoopInfoMap[HMacros[i]->getKI()].SplitSize;
            } else {
              loop = 1;
              loopsize = 0;
            }
            unsigned k = 0;
            for (; k < 3; k++) {
              bool allocatable = true;
              for (unsigned l = 0; l < IPath[k].size(); l++) {
                for (unsigned newloop = 0; newloop < loop; newloop++) {
                  for (unsigned testloop = 0;
                       testloop < IPath[k][l].loop;
                       testloop++) {
                    if (ocuppy + newloop * loopsize ==
                        IPath[k][l].birth + testloop * IPath[k][l].loopsize) {
                      allocatable = false;
                      break;
                    }
                  }
                  if (!allocatable) break;
                }
              }
              if (!allocatable) continue;
              //delete MPI->getOperand(3);
              (*MPI->getOperands())[3] = SHARED_OPRD(Imm, k + 1, SMLoc(), SMLoc());
              IPath[k].push_back(*new struct lifespan);
              IPath[k].back().birth = ocuppy;
              IPath[k].back().loop = loop;
              IPath[k].back().loopsize = loopsize;
              break;
            }
            if (k == 3) errs() << "IPaths are out of use.\n";
          }
          MPI = MPI->getNext();
        }
      }
    }
  }
}
  
void APDLGen::GenAPDLTree(void) {
  for (unsigned i = 0; i < HMacros.size(); i++) {
    if (HMacros[i]->getParent()) {
      unsigned j;
      for (j = 0; j < HMacros.size(); j++) {
        if (HMacros[j] == HMacros[i]->getParent()) {
          if (HMacros[i]->getStart() < HMacros[i]->getParent()->getStart())
            HMacros[i]->getParent()->setStart(HMacros[i]->getStart());
          break;
        }
      }
      if (j == HMacros.size()) {
        HMacros[i]->getParent()->setStart(HMacros[i]->getStart());
        HMacros.push_back(HMacros[i]->getParent());
      }
    }
  }
}
  
void APDLGen::FixupFragmentInst(void) {
  /* Try to merge dmem/treg/mreg = mac and mac += ... into
   dmem/treg/mreg = mr += ...
   */
  uint64_t vr = 0;
  unsigned fixup = 0;
  while (!FragmentInsts.empty()) {
    MCParsedInst *FI = FragmentInsts.front();
    errs() << "fix FI:" << FI << ":" << FI->getParent() << "\n";
    FragmentInsts.erase(FragmentInsts.begin());
    unsigned opc = CAST_TO_MMPU_OPRD(FI->getOperand(0))->getOpc();
    FI->getParent()->delInst(FI);
    switch (opc) {
    case IMRToBIU:
    case IMRToM:
    case IMRToMACC:
    case IMRToSHU:
      fixup = opc - IMRToBIU + 1;
      vr = SrcTable[FI][0];
        if (VRegTable[vr].producer) {
          opc = CAST_TO_MMPU_OPRD
                (VRegTable[vr].producer->getOperand(0))->getOpc();
          if (VRegTable[vr].producer->getParent() != FI->getParent()) {
            MCLoopBlock *parent = VRegTable[vr].producer->getParent();
            if (FI->getParent()->getType() == Loop)
              errs() << "Fragment insts reside in different loops";
            else {
              while (FI->getParent()->getParent() != parent) {
                if (parent) parent = parent->getParent();
                else break;
              }
              if (FI->getParent()->getParent() != parent)
                errs() << "Failed to merge Fragment inst\n";
              else {
                
              }
            }
          }
          switch (opc) {
            case IMA:
              errs() << "mr = a + b * c -> dmem/mreg/treg is not supported\n";
              break;
            case IMaC:
              //delete (*VRegTable[vr].producer->getOperands())[0];
              VRegTable[vr].producer->getOperands()
                ->erase(VRegTable[vr].producer->getOperands()->begin());
              for (unsigned i = 1; i < FI->getOperands()->size() - 3; i++) {
                VRegTable[vr].producer->getOperands()
                  ->insert(VRegTable[vr].producer->getOperands()->begin(),
                           (*FI->getOperands())[i]);
              }
              VRegTable[vr].producer->getOperands()
                ->insert(VRegTable[vr].producer->getOperands()->begin(),
                         SHARED_OPRD(Opc, opc + fixup, SMLoc(), SMLoc()));
              
              break;
            case IMAcc:
              break;
            default:
              break;
          }
        }
        
      break;
        
    default:
      break;
    }
  }
}
}
