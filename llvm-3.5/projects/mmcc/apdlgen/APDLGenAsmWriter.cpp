//===------- apdlgen/APDLGenAsmWriter.cpp - APDL Assembly Writer---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===--------------------------------------------------------------------===//
//
//
//===--------------------------------------------------------------------===//

#include "MMPUAPDLGen.h"
#include "MMPUAST.h"
#include "MMPUSymbol.h"
#include "MMPUBlock.h"
#include "AsmParser/MMPULiteScheduler.h"
#include <list>

using namespace llvm;
using namespace Lite;
using namespace MMPULite;

namespace llvm {

class MMPULiteInstPrinter {
public:
  MMPULiteInstPrinter() { }

  void printInst(const MCInst *MI, raw_ostream &O, StringRef Annot);

  /****************** autogenerated by tblgen ********************/
  void printInstruction(const MCInst *MI, raw_ostream &O);

  static const char *getRegisterName(unsigned RegNo);
  /***************************************************************/

  void printOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;

  void printFlags(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;

  void printKIReg(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;

  void printIPath(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;

  void printMACCTI(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;

  void printSHUT(const MCInst *MI, unsigned OpNo, raw_ostream &O) const;
};
}
void MMPULiteInstPrinter::printInst(const MCInst *MI, raw_ostream &O,
                                    StringRef Annot) {
  O << "\t"; // at start of line

  bool isAllNOP = true; // test whether all inst are NOP
  const MCInst *curinst = MI;
  std::string split = "";
  do {
    if (curinst == MI)
      curinst = curinst->getOperand(0).getInst();
    else
      curinst = curinst->getOperand(curinst->getNumOperands()-1).getInst();
    if (curinst->getOpcode() != MMPULite::NOP) {
      O << split;
      printInstruction(curinst, O);
      split = "|| ";
      isAllNOP = false;
    }
  } while (curinst->getNumOperands() &&
           curinst->getOperand(curinst->getNumOperands()-1).isInst());
  if(isAllNOP) {
    O << "NOP";
  }
  O << ";";
  //printAnnotation(O, Annot);

  return;
}

void MMPULiteInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
                                       raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);

  if (MO.isReg()) {
    O << getRegisterName(MO.getReg());
  } else if (MO.isExpr()) {
    O << *(MO.getExpr());
  } else if (MO.isImm())
    switch(MI->getOpcode()) {
    case MMPULite::LPTO:
    case MMPULite::JUMP:
    case MMPULite::JUMPK:
      if (OpNo == 0)
        O << "(" << MO.getImm() << "f)";
      else
        O << MO.getImm();
      break;
    default:
      O << MO.getImm();
      break;
    }
  else {
    assert(false && "Unknown operand");
  }
}

void MMPULiteInstPrinter::printFlags(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);

  int64_t flags = MO.getImm();

  std::string comma = "";
  if (flags) {
    O << "(";
    if(flags & (1 << BF)) {O << comma << "B"; comma = ", ";}
    if(flags & (1 << HF)) {O << comma << "H"; comma = ", ";}
    if(flags & (1 << UF)) {O << comma << "U"; comma = ", ";}
    if(flags & (1 << TF)) {O << comma << "T"; comma = ", ";}
    if(flags & (1 << SF)) {O << comma << "S"; comma = ", ";}
    if(flags & (1 << DF)) {O << comma << "D"; comma = ", ";}
    if(flags & (1 << IF)) {O << comma << "I"; comma = ", ";}
    if(flags & (1 << LF)) {O << comma << "L"; comma = ", ";}
    if(flags & (1 << APPF)) {O << comma << "A++"; comma = ", ";}
    if(flags & (1 << KPPF)) {O << comma << "K++"; comma = ", ";}
    if(flags & (1 << CRF)) {O << comma << "CR"; comma = ", ";}
    if(flags & (1 << BRF)) {O << comma << "BR"; comma = ", ";}
    if(flags & (1 << MF)) {O << comma << "M"; comma = ", ";}
    if(flags & (1 << TCF)) {O << comma << "TC"; comma = ", ";}
    O << ")";
  }
}

void MMPULiteInstPrinter::printKIReg(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);

  unsigned kis = (MO.getImm()) & 0x3F;
  if (kis & 0x10) O << "!";
  O << "KI" << (kis & 0xF);
  kis = (MO.getImm()>>5) & 0x3F;
  if (kis) {
    O << "&";
    if (kis & 0x10) O << "!";
    O << "KI" << (kis & 0xF);
  }
  kis = (MO.getImm()>>11) & 0x3F;
  if (kis) {
    O << "&";
    if (kis & 0x10) O << "!";
    O << "KI" << (kis & 0xF);
  }
  kis = MO.getImm()>>17;
  if (kis) {
    O << "&";
    if (kis & 0x10) O << "!";
    O << "KI" << (kis & 0xF);
  }
}

void MMPULiteInstPrinter::printIPath(const MCInst *MI, unsigned OpNo,
                                     raw_ostream &O) const {
  const MCOperand& MO = MI->getOperand(OpNo);

  unsigned path = (MO.getImm()) & 0x3;
  if (path)
    O << "(I" << path - 1 << ")";
}

void MMPULiteInstPrinter::printMACCTI(const MCInst *MI, unsigned int OpNo,
                                      raw_ostream &O) const {
  printOperand(MI, OpNo, O);
  O << ".";
  printOperand(MI, OpNo + 1, O);
  printIPath(MI, OpNo + 2, O);
}

void MMPULiteInstPrinter::printSHUT(const MCInst *MI,
                                    unsigned int OpNo,
                                    raw_ostream &O) const {
  printOperand(MI, OpNo, O);
  O << ".";
  printOperand(MI, OpNo + 1, O);
}

#include "MMPULiteGenAsmWriter.inc"

namespace MMPU {

void APDLGen::GenAPDLInst(MMPU::Block *BAst) {
  if (!APDLFunc) APDLFunc = new MCLoopBlock(Sequential, 0);
  MCLoopBlock *top = APDLFunc;
  APDLFunc = APDLFunc->addSubBlock(new MCLoopBlock(Sequential, 0));
  if (BAst && BAst->isAPDLBlock()) {
    if (BAst->getType() == Block::BLOCK_AST) genAST(BAst->getAST());
    else genBlock(BAst);
  }
  APDLFunc = top;
}

void APDLGen::GenAPDLTree(void) {
  for (unsigned i = 0; i < HMacros.size(); i++) {
    if (HMacros[i]->getParent()) {
      unsigned j;
      for (j = 0; j < HMacros.size(); j++) {
        if (HMacros[j] == HMacros[i]->getParent()) {
          if (HMacros[i]->getStart() < HMacros[i]->getParent()->getStart())
            HMacros[i]->getParent()->setStart(HMacros[i]->getStart());
          break;
        }
      }
      if (j == HMacros.size()) {
        HMacros[i]->getParent()->setStart(HMacros[i]->getStart());
        HMacros.push_back(HMacros[i]->getParent());
      }
    }
  }
}

void APDLGen::Emit(void) {
  MMPULiteInstPrinter* printer = new MMPULiteInstPrinter();
  MCInst *MI = NULL;
  std::map<MCLoopBlock *, uint64_t> HMacroMap;
  uint64_t HMacroID = 0;
  while (!HMacros.empty()) {
    if (HMacroMap.count(HMacros.back()) == 0)
      HMacroMap[HMacros.back()] = HMacroID++;
    *O << ".hmacro hm_" << HMacroMap[HMacros.back()] << "\n";
    if (HMacros.back()->getBlocks().size()) {
      uint64_t addr = HMacros.back()->getStart();
      unsigned i = 0;
      if (HMacros.back()->getType() == Loop) {
        *O << "LPTO (1f) @(KI" << HMacros.back()->getKI();
        if (HMacros.back()->getCount() != 0)
          *O << HMacros.back()->getCount();
        *O << ") ";
      }
      while (i < HMacros.back()->getBlocks().size()) {
        std::string split = "";
        for (unsigned j = 0; j < HMacros.back()->getBlocks().size(); j++) {
          uint64_t fixstart = HMacros.back()->getBlocks()[j]->getStart();
          if (HMacros.back()->getType() == Loop &&
              HMacros.back()->getBlocks()[j]->getType() != Loop) {
            errs() << "T: " << HMacros.back()->getBlocks()[j]->getType() << "\n";
            fixstart++;
          }
            /*else if (HMacros.back()->getType() != Loop &&
                     HMacros.back()->getBlocks()[j]->getType() == Loop &&
                     fixstart != 0)
              fixstart--;
            else if (HMacros.back()->getType() != Loop &&
                     HMacros.back()->getBlocks()[j]->getType() != Loop &&
                     fixstart == 0)
              fixstart++;*/
          if (addr == HMacros.back()->getStart() &&
              HMacros.back()->getType() == Loop)
            split = "||";
          errs() << "S: " << addr << "|" << HMacros.back()->getStart() << "|" << fixstart << "\n";
          if (fixstart == addr) {
            i++;
            HMacroMap[HMacros.back()->getBlocks()[j]] = HMacroID++;
            *O << split << " hm_"
               << HMacroMap[HMacros.back()->getBlocks()[j]];
            if (HMacros.back()->getType() == Loop) *O <<"()";
            *O << " ";
            split = "||";
          }
        }
        if (split == "") *O << "NOP;\n";
        else *O << ";\n";
        addr++;
      }
      if (HMacros.back()->getType() == Loop) *O << "1:\n";
    } else {
      if (HMacros.back()->getType() == Loop) {
        *O << "LPTO (1f) @(KI" << HMacros.back()->getKI();
        if (HMacros.back()->getCount() != 0)
          *O << HMacros.back()->getCount();
        *O << ");\n";
      }
      for (unsigned i = 0; i < HMacros.back()->getInsts().size(); i++) {
        MI = Translate(HMacros.back()->getInsts()[i]);
        if (MI) printer->printInst(MI, *O, "");
        *O << "\n";
      }
      if (HMacros.back()->getType() == Loop) *O << "1:\n";
    }
    *O << ".endhm\n\n";
    HMacros.pop_back();
  }
  delete printer;
}
}
