/*
 * replace the lexer generated by flex
 */

%%{
	machine UCPSInstrLexer;
	write data;
}%%

%%{ #// sub FSMs

main := |*
      'r'i ( '0' | ([1-9][0-9]*)) => {
		assert(atoi(ts+1)<32);
		yylval->op = 
		  UCPS::UCPSAsmOperand::createReg(
		    (UCPS::UCPSAsmParser::getRegInfo())
		      ->getRegClass(UCPSReg::RRegRegClassID).getRegister(atoi(ts+1)));
		
		CurLoc = SMLoc::getFromPointer(te); return _RReg;
	};
	
      'j'i ('0'|([1-9][0-9]*)) => {
		assert(atoi(ts+1)<32);
		yylval->op = 
		  UCPS::UCPSAsmOperand::createReg(
		    (UCPS::UCPSAsmParser::getRegInfo())
		      ->getRegClass(UCPSReg::JRegRegClassID).getRegister(atoi(ts+1)));
		
		
		CurLoc = SMLoc::getFromPointer(te); return _JReg;
	};
	
      "svr"i('0'|'1') => {
		yylval->op = UCPS::UCPSAsmOperand::createReg(
		  (UCPS::UCPSAsmParser::getRegInfo())
		    ->getRegClass(UCPSReg::SVRRegRegClassID).getRegister(atoi(ts+3)));
		
		
		CurLoc = SMLoc::getFromPointer(te); return _SVRReg;
	};
	
  "cctrl"i => { CurLoc = SMLoc::getFromPointer(te); return _CCtrl; };
  "cstat"i => { CurLoc = SMLoc::getFromPointer(te); return _CStat; };
  "stat"i  => { CurLoc = SMLoc::getFromPointer(te); return _Stat; };
  "lpctr"i => { CurLoc = SMLoc::getFromPointer(te); return _LPCtr; };
  "mc"i    => { CurLoc = SMLoc::getFromPointer(te); return _MC; };
  "vect"i  => { CurLoc = SMLoc::getFromPointer(te); return _Vect;};

  "==" => { CurLoc = SMLoc::getFromPointer(te); return _EQ; };
  "!=" => { CurLoc = SMLoc::getFromPointer(te); return _NE; };
  ">"  => { CurLoc = SMLoc::getFromPointer(te); return _GT; };
  ">=" => { CurLoc = SMLoc::getFromPointer(te); return _GE; };
  "<"  => { CurLoc = SMLoc::getFromPointer(te); return _LT; };
  "<=" => { CurLoc = SMLoc::getFromPointer(te); return _LE; };

  "<<" => { CurLoc = SMLoc::getFromPointer(te); return _SL; };
  ">>" => { CurLoc = SMLoc::getFromPointer(te); return _SR; };

  ";;" => { CurLoc = SMLoc::getFromPointer(te); return _EOS; };
  ";"  => { CurLoc = SMLoc::getFromPointer(te); return _Pl; };
  "+=" => { CurLoc = SMLoc::getFromPointer(te); return _PlusE; };
  
  "abs"i 	 	=> { CurLoc = SMLoc::getFromPointer(te); return _Abs;};
  "rf"i 	 	=> { CurLoc = SMLoc::getFromPointer(te); return _RF;};
  "rsqrt"i 	=> { CurLoc = SMLoc::getFromPointer(te); return _RSqRt;};
  "recip"i 	 	=> { CurLoc = SMLoc::getFromPointer(te); return _Recip;};
  "single"i	=> { CurLoc = SMLoc::getFromPointer(te); return _Single;};
  "double"i	=> { CurLoc = SMLoc::getFromPointer(te); return _Double;};
  "int"i 		=> { CurLoc = SMLoc::getFromPointer(te); return _Int;};
  "uint"i 		=> { CurLoc = SMLoc::getFromPointer(te); return _UInt;};
  "jump"i 		=> { CurLoc = SMLoc::getFromPointer(te); return _Jump;};
  "call"i 		=> { CurLoc = SMLoc::getFromPointer(te); return _Call;};
  "callm"i 		=> { CurLoc = SMLoc::getFromPointer(te); return _CallM;};
  "syscall"i  => { CurLoc = SMLoc::getFromPointer(te); return _SysCall;};
  "if"i 			=> { CurLoc = SMLoc::getFromPointer(te); return _If;};
  "lpto"i 		=> { CurLoc = SMLoc::getFromPointer(te); return _LpTo;};
  "by"i 			=> { CurLoc = SMLoc::getFromPointer(te); return _By;};
  "stop"i |
  "spu"i[ \t]*'.'[ \t]*"stop"i |
  "spustop"i => { CurLoc = SMLoc::getFromPointer(te); return _Stop;};
  "nop"i => { CurLoc = SMLoc::getFromPointer(te); return _NOP;};
  "ch"i => { CurLoc = SMLoc::getFromPointer(te); return _CH;};
  
  
  '+'	|
  '~'	|
  '-'	|
  '*'	|
  '&'	|
  '|'	|
  '^'	|
  '='	|
  ','	|
  '.' |
  '['	|
  ']'	|
  '(' |
  ')' |
  '{' |
  '}' |
  '#' 	=> {CurLoc = SMLoc::getFromPointer(te); return *ts;};
  
  '('[ \t]*"l0"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _L0;};
  '('[ \t]*"l1"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _L1;};
  '('[ \t]*"at"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _AT;};
  '('[ \t]*"t"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _T;};
  '('[ \t]*"b"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _B;};
  '('[ \t]*'h'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _H;};
  '('[ \t]*'l'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _L;};
  '('[ \t]*'n'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _N;};
  '('[ \t]*'u'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _U;};
  '('[ \t]*'s'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _S;};
  '('[ \t]*'d'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _D;};
  '('[ \t]*"ci"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _CI;};
  '('[ \t]*"flag"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _Flag;};
  '('[ \t]*"column"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _Column;};
  '('[ \t]*"step"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _Step;};
  '('[ \t]*"e"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _E;};
  '('[ \t]*"i"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _I;};
  '('[ \t]*'x'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _X;};
  '('[ \t]*'y'i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _Y;};
  '('[ \t]*"xy"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _XY;};
  '('[ \t]*"shift"i[ \t]*')' => { CurLoc = SMLoc::getFromPointer(te); return _SHIFT;};
  
  '-'?([0-9]+|("0x"i[0-9a-f]+))	=> {
    // let llvm handle expression
		// yylval->op = UCPS::UCPSAsmOperand::createImm(strtol(ts, NULL, 0));
		CurLoc = SMLoc::getFromPointer(ts); return _Imm;
	};

  '-'?[0-9]+'.'[0-9]*                |
  '-'?[0-9]+'.'[0-9]*('e'i['-''+']?[0-9]+)  |
  '-'?'.'[0-9]+			          |
  '-'?'.'[0-9]+('e'i['-''+']?[0-9]+)  |
  '-'?[0-9]+('e'i['-''+']?[0-9]+)     => {
		yylval->op = UCPS::UCPSAsmOperand::createFPImm(strtod(ts, NULL));
		CurLoc = SMLoc::getFromPointer(te); return _FPImm;
	};
	
  [a-zA-Z_][a-zA-Z_0-9]* => {
    // let llvm handle expression
    //StringRef * ref = new StringRef(UCPS::UCPSAsmParser::getParser()->getTok().getString().data(), strlen(ts));
    //yylval->op = UCPS::UCPSAsmOperand::createExpr(ref);
		CurLoc = SMLoc::getFromPointer(ts); return _Symb;
	};

  [ \t\n\r]+			=> {};

  any => {  CurLoc = SMLoc::getFromPointer(ts); return *ts; }; 

*|;

}%%

// a direct wrapper for lexer generated by ragel.
// *start* is modified when this wrapper CurLoc = SMLoc::getFromPointer(te); returns.
static int ucpstoklex(YYSTYPE *yylval, MCAsmParser *parser, SMLoc &CurLoc) {
 AsmLexer &lexer = static_cast<AsmLexer &>(parser->getLexer());
  const char *p  = CurLoc.getPointer(); 	// start point for ragel lexing.
  const char *pe = lexer.peekTok(true).getEndLoc().getPointer() + 1;   	// line end.

	// vars for ragel scanners
  int cs; // init state
	const char *ts, *te;
	int act;

	const char *eof = 0;
	
	%% write init;

	// variables accessed within ragel blocks
  int token = -1;

  // this is where ragel-lexer works.
  do {
    pe = lexer.peekTok(true).getEndLoc().getPointer() + 1;    // line end.
    %% write exec;
    if (ts != 0) lexer.Lex();
    else break;
    p = pe;
  } while (ts != 0);

  CurLoc = SMLoc::getFromPointer(te); return token;
}
