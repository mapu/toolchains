/* This is a flex file for UCPM instruction lexer which cooperates with UCPM
 * instruction parser. This custom instruction lexer is a low-level, UCPM-specific
 * instruction lexer to analyze just one UCPM instruction line
 * (an VLIW instruction line). It is distinguished from LLVM platform generic
 * lexer and target-specific lexer. A similar description is created for UCPM
 * instruction parser.
 * See UCPMInstrParser.y for more details.
 */

%{
#include "UCPMGenInstrParser.h" // generated by bison, including definition of tokens and data types
#include <string>
#include "llvm/ADT/SmallString.h"
#include "llvm/MC/MCParser/AsmLexer.h"
#define SAVE_TOKEN yylval->string = new std::string(ucpmtext, ucpmleng)
#define TOKEN(t) (yylval->token = t)
#define YY_USER_ACTION                                                         \
  yylloc->S = TokStart;                                                        \
  yylloc->E = SMLoc::getFromPointer(yylloc->S.getPointer() + ucpmleng);    \
  TokStart = yylloc->E;
%}

/* list all needed compiling option so we can simplify makefiles */
/*%option outfile="UCPMGenInstrLexer.flex"
%option header-file="UCPMGenInstrLexer.h"*/

/*%option debug*/
/*%option trace*/
%option bison-bridge
%option bison-locations

%option prefix="ucpm"

/* yywrap() is a function to invoke for EOF. */
%option noyywrap

/* suppress stdout for unmatched input */
%option nodefault

/* suppress unput() */
%option nounput

%x EXPRPARSE PARENEXPRPARSE CONDPARSE

L   [a-zA-Z_]
A   [a-zA-Z_0-9]

%% /*---------------------------section delimiter--------------------------------*/

	/* register classes with lower-case names */
<EXPRPARSE>[ \t\n]                {;}
<EXPRPARSE>"("                    {BEGIN PARENEXPRPARSE;}
<EXPRPARSE>0[xX][[:xdigit:]]+                 { /* hex */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(2).c_str(),0,16);
  return IMM5;
}
<EXPRPARSE>[1-9][0-9]*    { /* dec */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=atol(yylval->string->c_str());
  return IMM5;
}
<EXPRPARSE>0[01234567]+                       { /* oct */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(1).c_str(),0,8);
  return IMM5;
}
<EXPRPARSE>0+                       { /* num '0' */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=0;
  return IMM5;
}




<EXPRPARSE>"t"[0-3]               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(1)).c_str()); BEGIN INITIAL; return TREG;}
<PARENEXPRPARSE>"ki"[0-9]+        {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()); BEGIN INITIAL; return KI;}
<EXPRPARSE>{L}{A}*                {
  BEGIN INITIAL;
  while (Lexer->getTok().getLoc() != yylloc->S) Lexer->Lex();
  SAVE_TOKEN;
  const MCExpr *Res;
  StringRef Identifier;
  SMLoc End = Lexer->getTok().getEndLoc();
  SMLoc Start = Lexer->getTok().getLoc();
  if (llvmParser->parseIdentifier(Identifier)) {
    llvmParser->TokError("Invalid Identifier");
    REJECT;
  }
  ucpm_flush_buffer(YY_CURRENT_BUFFER);
  MCSymbol *Sym = llvmParser->getContext().getOrCreateSymbol(Identifier); 
  if (Sym->isVariable() && isa<MCConstantExpr>(Sym->getVariableValue()))
    Res = Sym->getVariableValue();
  else
    Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, llvmParser->getContext());
  yylval->op = UCPM::UCPMAsmOperand::createExpr(Res, Start, End);
  yylloc->S = Start;
  yylloc->E = End;
  TokStart = Lexer->getLoc();
  ucpmleng = End.getPointer() - Start.getPointer() + 1;
  CurLoc = Lexer->getLoc();
  return EXPR;
}
<PARENEXPRPARSE>[ \t\n]                {;}
<PARENEXPRPARSE>"!"                {return TOKEN(NEG);}
<PARENEXPRPARSE>"c"                {BEGIN INITIAL; return TOKEN(C);}
<PARENEXPRPARSE>[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"("|"-" {
  BEGIN INITIAL;
  while (Lexer->getTok().getLoc() != yylloc->S) Lexer->Lex();
  SAVE_TOKEN;
  SMLoc End;
  SMLoc Start = Lexer->getTok().getLoc();
  const MCExpr *IdVal = 0;
  if (llvmParser->parseExpression(IdVal, End)) {
    llvmParser->Error(Start, "Invalid expression");
    REJECT;
  }
  ucpm_flush_buffer(YY_CURRENT_BUFFER);
  if (Lexer->isNot(AsmToken::RParen)) {
    llvmParser->Error(End, "Right parenthesis is expected here: " + Twine(yylloc->S.getPointer()));
    REJECT;
  }
  llvmParser->Lex();
  CurLoc = Lexer->getLoc();
  yylloc->S = Start;
  yylloc->E = End;
  TokStart = Lexer->getLoc();
  ucpmleng = End.getPointer() - Start.getPointer() + 1;
  const MCConstantExpr *CE = dyn_cast<MCConstantExpr>(IdVal);
  if (!CE) {
    yylval->op = UCPM::UCPMAsmOperand::createExpr(IdVal, Start, End);
    return EXPR;
  }
  else {
    yylval->val = CE->getValue();
    if (yylval->val < 0) {
      llvmParser->Warning(Start, "Negative immediate is not allowed");
      return IMM;
    }
    return IMM5;
  }
}
<PARENEXPRPARSE>.                {}

0[xX][[:xdigit:]]+                 { /* hex */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(2).c_str(),0,16);
  return IMM5;
}
[1-9][0-9]*    { /* dec */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=atol(yylval->string->c_str());
  return IMM5;
}
0[01234567]+                       { /* oct */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=strtol(yylval->string->substr(1).c_str(),0,8);
  return IMM5;
}
0+                       { /* num '0' */
  BEGIN INITIAL;
  SAVE_TOKEN;
  yylval->val=0;
  return IMM5;
}
[ \t\n]                {;}
"->"                   {return TOKEN(ASSIGNTO);}
"=="                   {return TOKEN(EQU);}
"!="                   {return TOKEN(NEQ);}
"<"                    {return TOKEN(ST);}
"<="                   {return TOKEN(NLT);}
">"                    {return TOKEN(LT);}
">="                   {return TOKEN(NST);}
"("                    {return TOKEN(LPAREN);}
"{"                    {return TOKEN(LBRACE);}
<CONDPARSE>"("         {BEGIN PARENEXPRPARSE; return TOKEN(LPAREN);}
<CONDPARSE>[ \t\n]     {;}
<CONDPARSE>.           {BEGIN INITIAL;}
")"                    {return TOKEN(RPAREN);}
"}"                    {return TOKEN(RBRACE);}
"."                    {return TOKEN(DOT);}
","                    {return TOKEN(COMMA);}
"+"                    {return TOKEN(ADD);}
"-"                    {return TOKEN(SUB);}
"*"                    {return TOKEN(MUL);}
"**"                   {return TOKEN(CMUL);}
"<-"                   {return TOKEN(ASSIGN);}


"<<"                   {BEGIN EXPRPARSE; return TOKEN(LSHT);}
">>"                   {BEGIN EXPRPARSE; return TOKEN(RSHT);}
"|"                    {return TOKEN(OR);}
"&"                    {return TOKEN(AND);}
"^"                    {return TOKEN(XOR);}
"not"                  {return TOKEN(NOT);}
"!"                    {return TOKEN(NEG);}
"+-"                   {return TOKEN(ADDSUB);}
"+="                   {BEGIN EXPRPARSE; return TOKEN(ACC1);}
"=+"                   {BEGIN EXPRPARSE; return TOKEN(ACC2);}
"@"                    {BEGIN CONDPARSE; return TOKEN(ALPHA);}
"||"                   {return TOKEN(SPLIT);}
";"                    {return TOKEN(LINEEND);}

"shu0"                   {return TOKEN(SHU0);}
"shu1"                   {return TOKEN(SHU1);}
"shu2"                   {return TOKEN(SHU2);}
"ialu"                   {return TOKEN(IALU);}
"imac"                   {return TOKEN(IMAC);}
"falu"                   {return TOKEN(FALU);}
"fmac"                   {return TOKEN(FMAC);}
"ifalu"                   {return TOKEN(IFALU);}
"ifmac"                   {return TOKEN(IFMAC);}
"m"                      {return TOKEN(M);}
"biu0"                   {return TOKEN(BIU0);}
"biu1"                   {return TOKEN(BIU1);}
"biu2"                   {return TOKEN(BIU2);}
"r0"                     {return TOKEN(R0);}
"r1"                     {return TOKEN(R1);}
"r2"                     {return TOKEN(R2);}
"r3"                     {return TOKEN(R3);}
"r4"                     {return TOKEN(R4);}
"r5"                     {return TOKEN(R5);}
"biu"                    {return TOKEN(BIU);}
"i"[0-2]                 {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(1)).c_str()); return IPATH;} 
"t"[0-3]                 {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(1)).c_str()); return TREG;} 
"m["[0-9]+"]"            {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2, ucpmleng-2)).c_str()); return MINDEXN;}
"m[s""++]"               {return TOKEN(MINDEXS);}
"m[i""++]"               {return TOKEN(MINDEXI);}
"cond"                   {return TOKEN(COND);}
"tb"                     {return TOKEN(TB);}
"tbb"                    {return TOKEN(TBB);}
"tbh"                    {return TOKEN(TBH);}
"tbw"                    {return TOKEN(TBW);}
"tbd"                    {return TOKEN(TBD);}
"tsq"                    {return TOKEN(TSQ);}
"ind"                    {return TOKEN(IND);}
"comb"                   {return TOKEN(BY);}
"cprs"                   {return TOKEN(CPRS);}
"expd"                   {return TOKEN(EXPD);}
"start"                  {return TOKEN(START);}
"stop"                   {return TOKEN(STOP);}
"max"                    {return TOKEN(MAX);}
"min"                    {return TOKEN(MIN);}
"abs"                    {return TOKEN(ABS);}
"merge"                  {return TOKEN(MERGE);}
"mdivr"                  {return TOKEN(MDIVR);}
"mdivq"                  {return TOKEN(MDIVQ);}
"divr"                   {return TOKEN(DIVR);}
"divq"                   {return TOKEN(DIVQ);}
"divs"                   {return TOKEN(DIVS);}
"rmax"                   {return TOKEN(RMAX);}
"rmin"                   {return TOKEN(RMIN);}
"recip"                  {return TOKEN(RECIP);}
"rsqrt"                  {return TOKEN(RSQRT);}
"single"                 {return TOKEN(SINGLE);}
"double"                 {return TOKEN(DOUBLE);}
"mr"                     {return TOKEN(MR);}
"int"                    {return TOKEN(INT);}
"repeat"                 {return TOKEN(REPEAT);}
"lpto"                   {BEGIN EXPRPARSE; return TOKEN(LOOP);}
"jump"                   {BEGIN EXPRPARSE; return TOKEN(JMP);}
"mpustop"                {return TOKEN(MPUSTOP);}
"br"                     {return TOKEN(BR);}
"cr"                     {return TOKEN(CR);}
"a""++"                  {return TOKEN(APP);}
"k""++"                  {return TOKEN(KPP);}
"ql"                     {return TOKEN(QL);}//dcx
"qh"                     {return TOKEN(QH);}//dcx
"q"                      {return TOKEN(Q);}//dcx
"u"                      {return TOKEN(U);}
"p"                      {return TOKEN(P);}
"r"                      {return TOKEN(R);}
"t"                      {return TOKEN(T);}
"shift0"                 {return TOKEN(SHIFT0);}
"shift1"                 {return TOKEN(SHIFT1);}
"shift2"                 {return TOKEN(SHIFT2);}
"shift3"                 {return TOKEN(SHIFT3);}
"send"                   {return TOKEN(SEND);}
"ci"                     {return TOKEN(CI);}
"f"                      {return TOKEN(F);}
"b"                      {return TOKEN(B);}
"h"                      {return TOKEN(H);}
"s"                      {return TOKEN(S);}
"stest"                  {return TOKEN(STEST);} //dcx
"d"                      {return TOKEN(D);}
"i"                      {return TOKEN(I);}
"c"                      {return TOKEN(CFLAG);}
"l"                      {return TOKEN(L);}
"tc"                     {return TOKEN(TC);}
"ki"[0-9]+               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()); return KI;}
"wf"[1-3]+               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()); return WFLAG;}
"wx"[1-4]+               {SAVE_TOKEN; yylval->val = atol((yylval->string->substr(2)).c_str()) + 3; return WFLAG;}
"true"                   {return TOKEN(TRUE);}
"nop"                    {return TOKEN(NOOP);}
"uint"                   {return TOKEN(UINT);}
"kg"                     {return TOKEN(KG);}
"dm"                     {return TOKEN(DM);}
{L}{A}*                  {SAVE_TOKEN; return IDENTIFIER;}
.                        {}
%%
