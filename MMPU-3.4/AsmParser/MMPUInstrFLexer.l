/* This is a flex file for MMPU instruction lexer which cooperates with MMPU
 * instruction parser. This custom instruction lexer is a low-level, MMPU-specific
 * instruction lexer to analyze just one MMPU instruction line
 * (an VLIW instruction line). It is distinguished from LLVM platform generic
 * lexer and target-specific lexer. A similar description is created for MMPU
 * instruction parser.
 * See MMPUInstrParser.y for more details.
 */

%{
#include "MMPUGenInstrParser.h" // generated by bison, including definition of tokens and data types
%}

/* list all needed compiling option so we can simplify makefiles */

/*%option outfile="MMPUGenInstrLexer.flex"*/
%option header-file="MMPUGenInstrLexer.h"

%option case-insensitive

/*%option debug*/
/*%option trace*/

%option bison-bridge
/*%option bison-locations*/

%option prefix="mmputok"

/* yywrap() is a function to invoke for EOF. */
%option noyywrap

/* suppress stdout for unmatched input */
%option nodefault

/* suppress unput() */
%option nounput

%% /*---------------------------section delimiter--------------------------------*/

	/* register classes with lower-case names */
m(0|([1-9][0-9]*)) {
    unsigned num = atoi(mmputoktext+1);
		assert(num<128);
		yylval->token->num = num;
		return _MReg;
	}

m((0|([1-9][0-9]*)):(0|([1-9][0-9]*))) {
    unsigned num = atoi(mmputoktext+1);
    assert(num<128);
    const char * p = (const char *)memchr(mmputoktext, ':', mmputokleng);
    unsigned num1 = atoi(p+1);
    assert((num+1)%128 == num1);
    yylval->token->num = num;
    return _MRegExt;
  }

m[ \t]*\[[ \t]*i[ \t]*\+\+[ \t]*\] {
    yylval->token->num = 128;
    return _MReg;
  }

m[ \t]*\[[ \t]*s[ \t]*\+\+[ \t]*\] {
    yylval->token->num = 129;
    return _MReg;
  }

shu(0|1) {
    yylval->token->reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::ShuRegClassID).getRegister(atoi(mmputoktext+3));
		return _Shu;
	}

ialu {
		yylval->token->reg = MMPUReg::IALU;
		return _Calc;
	}

imac {
    yylval->token->reg = MMPUReg::IMAC;
		return _Calc;
	}

falu {
    yylval->token->reg = MMPUReg::FALU;
		return _Calc;
	}

fmac {
    yylval->token->reg = MMPUReg::FMAC;
		return _Calc;
	}

biu(0|1|2) {
		yylval->token->reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::BIURegClassID).getRegister(atoi(mmputoktext+3));
		return _BIU;
	}

r0 {
		yylval->token->reg = MMPUReg::r0;
		return _r0;
	}

r1 {
    yylval->token->reg = MMPUReg::r1;
    return _r1;
  }

r2 {
    yylval->token->reg = MMPUReg::r2;
    return _r2;
  }

r3 {
    yylval->token->reg = MMPUReg::r3;
    return _r3;
  }

w(0|1|2) {
		yylval->token->reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::WPortRegClassID).getRegister(atoi(mmputoktext+1));
		return _WPort;
	}

w3 {
    yylval->token->reg = MMPUReg::w3;
    return _w3;
  }

i(0|1|2) {
    yylval->token->reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::IPortRegClassID).getRegister(atoi(mmputoktext+1));
    return _IPort;
  }

t(0|1|2|3) {
    yylval->token->num = atoi(mmputoktext+1);
    return _TPort;
  }

tbb {
    yylval->token->num = 4;
    return _TPort;
  }

tbh {
    yylval->token->num = 5;
    return _TPort;
  }

tbw {
    yylval->token->num = 6;
    return _TPort;
  }

tbd {
    yylval->token->num = 7;
    return _TPort;
  }

tsq {
    yylval->token->num = 8;
    return _TPort;
  }

t((0:1)|(1:2)|(2:3)|(3:0)) {
    yylval->token->num = atoi(mmputoktext+1);
    return _TPortExt;
  }

ki(0|([1-9][0-9]*)) {
		assert(atoi(mmputoktext+2)<16);
		yylval->token->flags = atoi(mmputoktext+2);
		return _KIReg;
}

\([ \t]*ind[ \t]*\)   { yylval->token->flags = 1<<MMPUFlag::Ind; return _Ind; }
\([ \t]*m[ \t]*\) 		{	yylval->token->flags = 1<<MMPUFlag::M;		return _M; }
\([ \t]*br[ \t]*\) 		{ yylval->token->flags = 1<<MMPUFlag::BR;	return _BR; }
\([ \t]*a\+\+[ \t]*\) {	yylval->token->flags = 1<<MMPUFlag::APP;	return _APP; }
\([ \t]*k\+\+[ \t]*\) {	yylval->token->flags = 1<<MMPUFlag::KPP;	return _KPP; }

\([ \t]*t[ \t]*\) 	  {	yylval->token->flags = 1<<MMPUFlag::T;	return   _T; }
\([ \t]*u[ \t]*\) 	  {	yylval->token->flags = 1<<MMPUFlag::U; return   _U; }
\([ \t]*b[ \t]*\) 	  {	yylval->token->flags = 1<<MMPUFlag::B;	return   _B; }
\([ \t]*h[ \t]*\) 	  {	yylval->token->flags = 1<<MMPUFlag::H;	return   _H; }
\([ \t]*s[ \t]*\) 	  {	yylval->token->flags = 1<<MMPUFlag::S;	return   _S; }
\([ \t]*d[ \t]*\) 	  {	yylval->token->flags = 1<<MMPUFlag::D;	return   _D; }

\([ \t]*c[ \t]*\)     {   return   _C; }
\([ \t]*![ \t]*c[ \t]*\) {   return   _NC; }
\([ \t]*l[ \t]*\) 	  {		return   _L; }
\([ \t]*cr[ \t]*\) 	  {		return   _CR; }
\([ \t]*i[ \t]*\) 	  {		return   _I; }
\([ \t]*tc[ \t]*\)     {   return   _TC; }

\([ \t]*wf1[ \t]*\)     {   return   _WF1; }
\([ \t]*wf2[ \t]*\)     {   return   _WF2; }
\([ \t]*wf3[ \t]*\)     {   return   _WF3; }
\([ \t]*wx1[ \t]*\)     {   return   _WX1; }
\([ \t]*wx2[ \t]*\)     {   return   _WX2; }
\([ \t]*wx3[ \t]*\)     {   return   _WX3; }
\([ \t]*wx4[ \t]*\)     {   return   _WX4; }

"by"  		{ return _By;}
"c"       |
"cond"    { return _COND; }
"copy"      { return _Copy;}
"cprs"      { return _Cprs;}
"dm"			{ return _DM;}
"expd"      { return _Expd;}
"if" 			{ return _If;}
"ind"     |
"indx" 		{ return _Indx; }
"kg"			{ return _KG;}
"nop" 		{ return _NOP;}
"start"  	{ return _Start;}
"stop"  	{ return _Stop;}
"divr"    { return _DivR;}
"divs"    { return _DivS;}
"divq"    { return _DivQ;}
"mdivr"    { return _MDivR;}
"mdivq"    { return _MDivQ;}
"tb"  		{ return _TB;}
"repeat"  { return _Repeat;}
"jump"  	{ return _Jump;}
"lpto"  	{ return _Loop;}
"mpu"  		{ return _MPU;}
"mr"      { return _MR;}
"max"     { return _Max;}
"min"     { return _Min;}
"+-"      { return _AddSub;}
"=+"  { return _EAdd; }
"+="  { return _AddE; }
"abs" { return _Abs;}
"comb" { return _Comb;}

"at" |
"@"  { return _At;}

"int" 		{ return  _Int; }
"uint" 		{ return  _UInt; }

"single" 	{ return  _Sgl; }
"double" 	{ return  _Dbl; }
"recip"  { return  _Recip; }
"rsqrt"  { return  _RSqRt; }

"==" { return _EQ;  }
"!=" { return _NE;  }
">=" { return _GE;  }
"<=" { return _LE;  }
"<<" { return _SL;  }
">>" { return _SR;  }
";;" { return _Semicolon2;  }
"**" { return _CMul;  }

"~" |
"|" |
"^" |
">" |
"<" { return (*mmputoktext);  }

"+" |
"?" |
"-" |
"*" |
"=" |
"," |
"&" |
"[" |
"]" |
"." |
":" |
"(" |
")" |
"!" |
";"		{ return *mmputoktext; }

[ \t]*[0-9]+ 		|
0x([0-9]|[a-f])+	{
    //yylval->token->num = strtol(mmputoktext, NULL, 0);
		return _Imm;
	}

[_a-zA-Z][_a-zA-Z0-9]* {
    //StringRef ref(mmputoktext, mmputokleng);
    //MCAsmParser* mcparser = MMPU::MMPUAsmParser::getMCParser();
    //yylval->token->symb = mcparser->getContext().GetOrCreateSymbol(ref);
		return _Symb;
	}

[ \t]			{ }
\n 				{ return _EOL; }

. 	{ return _Err; /*printf("flex scanned unknown character: %c\n", *mmputoktext);*/ }
