/*
 * replace the lexer generated by flex
 */

%%{
	machine MMPUInstrLexer;
	write data;
}%%

%%{ #// sub FSMs
	main := |*

'm'i ( '0' | ([1-9][0-9]*)) {
		  unsigned num = atoi(ts+1);
		  assert(num<128);
		  yylval->token.num = num;
		  yylval->token.pos = ts;
		  mmpu_record_token_positions(ts, te, start); return t_MReg;
	};

'm'i ( '0' | ([1-9][0-9]*)) ':' ( '0' | ([1-9][0-9]*)) {

    unsigned num = atoi(ts+1);
    assert(num<128);
    const char * p = (const char *)memchr(ts, ':', te-ts);
    unsigned num1 = atoi(p+1);
    assert((num+1)%128 == num1);

    yylval->token.num = num;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);   return t_MRegExt;
  };

'm'i [ \t]* '[' [ \t]* 'i'i [ \t]* "++" [ \t]* ']' {
      yylval->token.num = 128;
      yylval->token.pos = ts;
      mmpu_record_token_positions(ts, te, start); return t_MReg;
  };

'm'i [ \t]* '[' [ \t]* 's'i [ \t]* "++" [ \t]* ']' {
      yylval->token.num = 129;
      yylval->token.pos = ts;
      mmpu_record_token_positions(ts, te, start); return t_MReg;
  };

"shu"i ('0' | '1') {
    yylval->token.reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::ShuRegClassID).getRegister(atoi(ts+3));
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_Shu;
  };

"ialu"i {
    yylval->token.reg = MMPUReg::IALU;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_Calc;
  };

"imac"i {
    yylval->token.reg = MMPUReg::IMAC;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_Calc;
  };

"falu"i {
    yylval->token.reg = MMPUReg::FALU;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_Calc;
  };

"fmac"i {
    yylval->token.reg = MMPUReg::FMAC;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_FMAC;
  };

"biu"i ('0'|'1'|'2') {
    yylval->token.reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::BIURegClassID).getRegister(atoi(ts+3));
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_BIU;
  };

"r0"i {
    yylval->token.reg = MMPUReg::r0;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_r0;
  };

"r1"i {
    yylval->token.reg = MMPUReg::r1;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_r1;
  };

"r2"i {
    yylval->token.reg = MMPUReg::r2;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_r2;
  };

"r3"i {
    yylval->token.reg = MMPUReg::r3;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_r3;
  };

'w'i('0'|'1'|'2') {
    yylval->token.reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::WPortRegClassID).getRegister(atoi(ts+1));
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_WPort;
  };

"w3"i {
    yylval->token.reg = MMPUReg::w3;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_w3;
  };

'i'i('0'|'1'|'2') {
    yylval->token.reg = MMPU::MMPUAsmParser::getRegInfo()->getRegClass(MMPUReg::IPortRegClassID).getRegister(atoi(ts+1));
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_IPort;
  };

't'i('0'|'1'|'2'|'3') {
    yylval->token.num = atoi(ts+1);
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_TPort;
  };

"tbb"i {
    yylval->token.num = 4;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_TPort;
  };

"tbh"i {
    yylval->token.num = 5;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_TPort;
  };

"tbw"i {
    yylval->token.num = 6;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_TPort;
  };

"tbd"i {
    yylval->token.num = 7;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_TPort;
  };

"tsq"i {
    yylval->token.num = 8;
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_TPort;
  };

't'i("0:1"|"1:2"|"2:3"|"3:0") {
    yylval->token.num = atoi(ts+1);
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_TPortExt;
  };

"ki"i('0'|([1-9][0-9]*)) {
    assert(atoi(ts+2)<16);
    yylval->token.options = atoi(ts+2);
    yylval->token.pos = ts;
    mmpu_record_token_positions(ts, te, start);
    return t_KIReg;
};

'(' [ \t]* "k++"i [ \t]* ')' { yylval->token.options = MMPU::c_KPP; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return o_KPP; };
'(' [ \t]* "a++"i [ \t]* ')' { yylval->token.options = MMPU::c_APP; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return o_APP; };
'(' [ \t]* "br"i [ \t]* ')'  { yylval->token.options = MMPU::c_BR; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return o_BR; };
'(' [ \t]* 'm'i [ \t]* ')'   { yylval->token.options = MMPU::c_M; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return o_M; };

'(' [ \t]* "t"i [ \t]* ')'   { yylval->token.options = MMPU::c_T; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return   o_T; };
'(' [ \t]* "u"i [ \t]* ')'   { yylval->token.options = MMPU::c_U; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return   o_U; };
'(' [ \t]* "b"i [ \t]* ')'   { yylval->token.options = MMPU::c_B; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return   o_B; };
'(' [ \t]* "h"i [ \t]* ')'   { yylval->token.options = MMPU::c_H; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return   o_H; };
'(' [ \t]* "s"i [ \t]* ')'   { yylval->token.options = MMPU::c_S; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return   o_S; };
'(' [ \t]* "d"i [ \t]* ')'   { yylval->token.options = MMPU::c_D; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return   o_D; };
'(' [ \t]* "ind"i [ \t]* ')' { yylval->token.options = MMPU::c_IND; yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return o_IND; };

'(' [ \t]* "c"i [ \t]* ')'  { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_C; };
'(' [ \t]* "!" [ \t]* "c"i [ \t]* ')'    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_NC; };
'(' [ \t]* "l"i [ \t]* ')'  { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_L; };
'(' [ \t]* "cr"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_CR; };
'(' [ \t]* "i"i [ \t]* ')'  { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_I; };
'(' [ \t]* "tc"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_TC; };

'(' [ \t]* "wf1"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_WF1; };
'(' [ \t]* "wf2"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_WF2; };
'(' [ \t]* "wf3"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_WF3; };
'(' [ \t]* "wx1"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_WX1; };
'(' [ \t]* "wx2"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_WX2; };
'(' [ \t]* "wx3"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_WX3; };
'(' [ \t]* "wx4"i [ \t]* ')' { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);  return   o_WX4; };

"by"i      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_By;};

"c"i       |
"cond"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_COND; };
"copy"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Copy;};
"cprs"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Cprs;};
"dm"i      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_DM;};
"expd"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Expd;};
"rmax"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_RMax;};
"rmin"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_RMin;};
"if"i      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_If;};

"ind"i     |
"indx"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Indx; };
"kg"i      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_KG;};
"nop"i     { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_NOP;};
"start"i   { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Start;};
"stop"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Stop;};
"divr"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_DivR;};
"divs"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_DivS;};
"divq"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_DivQ;};
"mdivr"i   { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_MDivR;};
"mdivq"i   { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_MDivQ;};
"tb"i      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_TB;};
"repeat"i  { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Repeat;};
"jump"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Jump;};
"lpto"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Loop;};
"mpu"i     { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_MPU;};
"mr"i      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_MR;};
"max"i     { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Max;};
"min"i     { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Min;};
"acs"i     { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_ACS;};
"+-"      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_AddSub;};
"=+"      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_EAdd; };
"+="      { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_AddE; };
"abs"i     { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Abs;};
"comb"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_Comb;};

"at"i      |
"@"       { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_At;};

"int"i     { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return  t_Int; };
"uint"i    { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return  t_UInt; };

"single"i  { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return  t_Sgl; };
"double"i  { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return  t_Dbl; };
"recip"i   { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return  t_Recip; };
"rsqrt"i   { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return  t_RSqRt; };

"==" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_EQ;  };
"!=" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_NE;  };
">=" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_GE;  };
"<=" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_LE;  };
"<<" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_SL;  };
">>" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_SR;  };
";;" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_EOS;  };
"**" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return t_CMul;  };

"~" |
"|" |
"^" |
">" |
"<" { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return (*ts);  };

"+" |
"?" |
"-" |
"*" |
"=" |
"," |
"&" |
"[" |
"]" |
"." |
":" |
"(" |
")" |
"!" |
";"   { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); return *ts; };


#### t_Imm and t_Symb will be handed over to llvm parser to do more proper processing.
[ \t]*[0-9]+    |
"0x"i ([0-9]|[a-f])+  {
    //yylval->token.num = strtol(ts, NULL, 0);
    yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);
    return t_Imm;
  };

[_a-zA-Z][_a-zA-Z0-9]* {
    //StringRef ref(ts, te-ts);
    //MCAsmParser* mcparser = MMPU::MMPUAsmParser::getMCParser();
    //yylval->token.symb = mcparser->getContext().GetOrCreateSymbol(ref);
    yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start);
    return t_Symb;
  };


[ \t\n\r]   { yylval->token.pos = ts; mmpu_record_token_positions(ts, te, start); };

any   { return t_Err; /*printf("flex scanned unknown character: %c\n", *ts);*/ };

*|;

}%%

static void mmpu_record_token_positions(const char * ts, const char * te, const char * &start)
{
  MMPU::MMPUAsmParser::setPreLoc(SMLoc::getFromPointer(ts));
  MMPU::MMPUAsmParser::setCurPosition(te);
  start = te;
}

// a direct wrapper for lexer generated by ragel.
// *start* is modified when this wrapper returns.
static int mmputoklex(YYSTYPE * yylval, const char * &start, const char * end)
{
  const char*p  = start; 	// start point for ragel lexing.
  const char*pe = end;   	// lexing end.

	// vars for ragel scanners
  int cs; // init state
	const char *ts, *te;
	int act;

	const char *eof = 0;

	// variables accessed within ragel blocks
  int token = -1;

  // this is where ragel-lexer works.
  %%{
		# Initialize and execute.
		write init;
		write exec;
  }%%

  return token;
}
