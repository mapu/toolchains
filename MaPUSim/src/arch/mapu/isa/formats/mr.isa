////////////////////////////////////////////////////////////////////
//
// M RegFile instructions
//
output header {{
using namespace MapuISA;

class MrOp : public MpuStaticInst {
protected:
  // Constructor
  MrOp(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
    : MpuStaticInst(mnem, _machInst, __opClass) {
    switch (SlotNum) {
    case 0:
      cond = MR0_C;
      c_not = MR0_CN;
      break;
    case 1:
      cond = MR1_C;
      c_not = MR1_CN;
      break;
    case 2:
      cond = MR2_C;
      c_not = MR2_CN;
      break;
    case 3:
      cond = MR3_C;
      c_not = MR3_CN;
      break;
    default:
      cond = false;
      c_not = false;
      break;
    }
  }

  void printDest(std::ostream &os, int dest) const;
  
  void printLeft(std::ostream &os) const;
  
  void printFlags(std::ostream &os) const;
};
}};

//Outputs to decoder.cc
output decoder {{
void MrOp::printDest(std::ostream &os, int dest) const {
  if (SlotNum == 3 && MRKG) {
    os << "->BIU" << BIUDEST << ".KG";
  } else {
    MpuStaticInst::printDest(os, dest);
  }
}

void MrOp::printLeft(std::ostream &os) const {
  printExpHead(os);
  if (_numSrcRegs > 0) {
    int reg = flattenedRegIdx(SlotNum, _srcRegIdx[0]);
    if (reg == 128) os << "M[I++]";
    else if (reg == 256) os << "M[S++]";
    else printReg(os, reg);
  }
  printExpTail(os);
  if (SlotNum == 3 || SlotNum == 2) printFlags(os);
}

void MrOp::printFlags(std::ostream &os) const {
  switch (MR2_W) {
  case 1:
  case 2:
  case 3:
    os << "(WF" << MR2_W << ")"; return;
  case 4:
  case 5:
  case 6:
  case 7:
    os << "(WX" << MR2_W - 3 << ")"; return;
  default: return;
  }
}
}};

def format MrOp(code, *opt_flags) {{
  iop = InstObjParams(name, Name, 'MrOp', code, opt_flags)
  header_output = BasicDeclare.subst(iop)
  decoder_output = BasicConstructor.subst(iop)
  decode_block = CondCheckDecode.subst(iop)
  exec_output = BasicExecute.subst(iop)
}};

