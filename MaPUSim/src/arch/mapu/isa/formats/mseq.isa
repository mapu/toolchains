////////////////////////////////////////////////////////////////////
//
// MPU sequencial unit instructions
//
output header {{
using namespace MapuISA;

class MseqOp : public MpuStaticInst {
protected:
  // Constructor
  MseqOp(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
    : MpuStaticInst(mnem, _machInst, __opClass) {
  }

  void printDest(std::ostream &os, int dest) const ;

  void printLeft(std::ostream &os) const;

  void printExpHead(std::ostream &os) const ;
};
}};

//Outputs to decoder.cc
output decoder {{
void MseqOp::printDest(std::ostream &os, int dest) const {
}

void MseqOp::printLeft(std::ostream &os) const {
  printExpHead(os);
  switch (MSEQ_OP) {
  case 0x1: ccprintf(os, "%d)", MSEQ_IMM10); break;
  case 0x4: break;
  default: {
    ccprintf(os, "KI%d", MSEQ_KI + 12);
    if (MSEQ_IMM4 != 0)
      ccprintf(os, "-%d", MSEQ_IMM4);
    ccprintf(os, ")");
  }
  break;
  }
}

void MseqOp::printExpHead(std::ostream &os) const {
  switch (MSEQ_OP) {
  case 0x1:
  case 0x2: os << "Repeat @("; break;
  case 0x3: {
    const SymbolTable *symtab = mdebugSymbolTable;
    std::string str;
    if (symtab && symtab->findSymbol(MSEQ_IMM10 * 41, str)) {
      ccprintf(os, "LpTo %s @(", str);
    } else ccprintf(os, "LpTo 0x%x @(", MSEQ_IMM10);
  }
  break;
  case 0x4: os << "Stop"; break;
  default: break;
  }
}

}};

def format MseqOp(code, *opt_flags) {{
  iop = InstObjParams(name, Name, 'MseqOp', code, opt_flags)
  header_output = BasicDeclare.subst(iop)
  decoder_output = BasicConstructor.subst(iop)
  decode_block = CondCheckDecode.subst(iop)
  exec_output = BasicExecute.subst(iop)
}};

