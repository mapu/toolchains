// -*- mode:c++ -*-

let {{
def LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                  postacc_code = '', base_class = 'Memory',
                  decode_template = BasicDecode, exec_template_base = ''):
    # Make sure flags are in lists (convert to lists if not).
    mem_flags = makeList(mem_flags)
    inst_flags = makeList(inst_flags)

    # Some CPU models execute the memory operation as an atomic unit,
    # while others want to separate them into an effective address
    # computation and a memory access operation.  As a result, we need
    # to generate three StaticInst objects.  Note that the latter two
    # are nested inside the larger "atomic" one.

    # Generate InstObjParams for each of the three objects.  Note that
    # they differ only in the set of code objects contained (which in
    # turn affects the object's overall operand list).
    iop = InstObjParams(name, Name, base_class,
                        { 'ea_code':ea_code, 'memacc_code':memacc_code, 'postacc_code':postacc_code },
                        inst_flags)

    if mem_flags:
        mem_flags = [ 'Request::%s' % flag for flag in mem_flags ]
        s = '\n\tmemAccessFlags = ' + string.join(mem_flags, '|') + ';'
        iop.constructor += s

    # select templates

    # The InitiateAcc template is the same for StoreCond templates as the
    # corresponding Store template..
    StoreCondInitiateAcc = StoreInitiateAcc

    fullExecTemplate = eval(exec_template_base + 'Execute')
    initiateAccTemplate = eval(exec_template_base + 'InitiateAcc')
    completeAccTemplate = eval(exec_template_base + 'CompleteAcc')

    # (header_output, decoder_output, decode_block, exec_output)
    return (LoadStoreDeclare.subst(iop),
            LoadStoreConstructor.subst(iop),
            decode_template.subst(iop),
            fullExecTemplate.subst(iop)
            + EACompExecute.subst(iop)
            + initiateAccTemplate.subst(iop)
            + completeAccTemplate.subst(iop))
}};

let {{
def BiuBase(name, Name, ea_code, memst_code, memld_code, inst_flags,
            postacc_code = '', base_class = 'BiuOp',
            decode_template = CondCheckDecode, exec_template_base = 'Biu'):
    # Make sure flags are in lists (convert to lists if not).
    inst_flags = makeList(inst_flags)

    iop = InstObjParams(name, Name, base_class,
                        { 'ea_code':ea_code, 'memst_code':memst_code, 'memld_code':memld_code, 'postacc_code':postacc_code },
                        inst_flags)

    fullExecTemplate = eval(exec_template_base + 'Execute')
    initiateAccTemplate = eval(exec_template_base + 'InitiateAcc')
    completeAccTemplate = eval(exec_template_base + 'CompleteAcc')
    eaCompTemplate = eval(exec_template_base + 'EACompExecute')

    # (header_output, decoder_output, decode_block, exec_output)
    return (LoadStoreDeclare.subst(iop),
            LoadStoreConstructor.subst(iop),
            decode_template.subst(iop),
            fullExecTemplate.subst(iop)
            + eaCompTemplate.subst(iop)
            + initiateAccTemplate.subst(iop)
            + completeAccTemplate.subst(iop))
}};

output header {{
        std::string inst2string(MachInst machInst);
}};

output decoder {{

std::string inst2string(MachInst machInst)
{
    string str = "";
    uint32_t mask = 0x80000000;

    for(int i=0; i < 32; i++) {
        if ((machInst & mask) == 0) {
            str += "0";
        } else {
            str += "1";
        }

        mask = mask >> 1;
    }

    return str;
}

}};
