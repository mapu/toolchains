////////////////////////////////////////////////////////////////////
//
// Memory-format instructions
//

output header {{
    /**
     * Base class for general Ucp memory-format instructions.
     */
    class Memory : public UcpStaticInst
    {
      protected:
        /// Memory request flags.  See mem_req_base.hh.
        Request::Flags memAccessFlags;

        /// Displacement for EA calculation (signed).
        int32_t disp;
        int32_t extop;
        int32_t extimm;


        /// Constructor
        Memory(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : UcpStaticInst(mnem, _machInst, __opClass),
              disp(IMMLS), extop(NEXTOPCODE), extimm(EXTIMM)
        {
            if( (disp >> 10) == 1) disp = disp | 0xFFFFFC00;
            if (extop == 0x5)
              disp = (disp & 0xF) | (extimm << 4);
        }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

     /**
     * Base class for a few miscellaneous memory-format insts
     * that don't interpret the disp field
     */
    class MemoryNoDisp : public Memory
    {
      protected:
        /// Constructor
        MemoryNoDisp(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : Memory(mnem, _machInst, __opClass)
        {
        }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };
}};


output decoder {{
    std::string
    Memory::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        std::stringstream ss;
        if ( (strcmp(mnemonic,"lwr") == 0) || (strcmp(mnemonic,"lbr") == 0) || (strcmp(mnemonic,"lhr") == 0)
          || (strcmp(mnemonic,"lbur") == 0) || (strcmp(mnemonic,"lhur") == 0) || (strcmp(mnemonic,"swr") == 0)
          || (strcmp(mnemonic,"sbr") == 0) || (strcmp(mnemonic,"shr") == 0) || 
             (strcmp(mnemonic,"lwrpost") == 0) || (strcmp(mnemonic,"lbrpost") == 0) || (strcmp(mnemonic,"lhrpost") == 0)
          || (strcmp(mnemonic,"lburpost") == 0) || (strcmp(mnemonic,"lhurpost") == 0) || (strcmp(mnemonic,"swrpost") == 0)
          || (strcmp(mnemonic,"sbrpost") == 0) || (strcmp(mnemonic,"shrpost") == 0)){
            ccprintf(ss, "%-10s %c%d, j%d(j%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'r', RD, JT, JS);
        }
        else if ( (strcmp(mnemonic,"lwj") == 0) || (strcmp(mnemonic,"lbj") == 0) || (strcmp(mnemonic,"lhj") == 0)
          || (strcmp(mnemonic,"lbuj") == 0) || (strcmp(mnemonic,"lhuj") == 0) || (strcmp(mnemonic,"swj") == 0)
          || (strcmp(mnemonic,"sbj") == 0) || (strcmp(mnemonic,"shj") == 0) ||
                   (strcmp(mnemonic,"lwjpost") == 0) || (strcmp(mnemonic,"lbjpost") == 0) || (strcmp(mnemonic,"lhjpost") == 0)
          || (strcmp(mnemonic,"lbujpost") == 0) || (strcmp(mnemonic,"lhujpost") == 0) || (strcmp(mnemonic,"swjpost") == 0)
          || (strcmp(mnemonic,"sbjpost") == 0) || (strcmp(mnemonic,"shjpost") == 0) ){
            ccprintf(ss, "%-10s %c%d, j%d(j%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'j', JD, JT, JS);
        }
        else if ( (strcmp(mnemonic,"lwir") == 0) || (strcmp(mnemonic,"lbir") == 0) || (strcmp(mnemonic,"lhir") == 0)
          || (strcmp(mnemonic,"lbuir") == 0) || (strcmp(mnemonic,"lhuir") == 0) || (strcmp(mnemonic,"swir") == 0)
          || (strcmp(mnemonic,"sbir") == 0) || (strcmp(mnemonic,"shir") == 0) ||
                  (strcmp(mnemonic,"lwirpost") == 0) || (strcmp(mnemonic,"lbirpost") == 0) || (strcmp(mnemonic,"lhirpost") == 0)
          || (strcmp(mnemonic,"lbuirpost") == 0) || (strcmp(mnemonic,"lhuirpost") == 0) || (strcmp(mnemonic,"swirpost") == 0)
          || (strcmp(mnemonic,"sbirpost") == 0) || (strcmp(mnemonic,"shirpost") == 0)){
            ccprintf(ss, "%-10s %c%d, %d(j%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'r', RD, disp, JS);
        }
        else if ( (strcmp(mnemonic,"lwij") == 0) || (strcmp(mnemonic,"lbij") == 0) || (strcmp(mnemonic,"lhij") == 0)
          || (strcmp(mnemonic,"lbuij") == 0) || (strcmp(mnemonic,"lhuij") == 0) || (strcmp(mnemonic,"swij") == 0)
          || (strcmp(mnemonic,"sbij") == 0) || (strcmp(mnemonic,"shij") == 0) ||
                  (strcmp(mnemonic,"lwijpost") == 0) || (strcmp(mnemonic,"lbijpost") == 0) || (strcmp(mnemonic,"lhijpost") == 0)
          || (strcmp(mnemonic,"lbuijpost") == 0) || (strcmp(mnemonic,"lhuijpost") == 0) || (strcmp(mnemonic,"swijpost") == 0)
          || (strcmp(mnemonic,"sbijpost") == 0) || (strcmp(mnemonic,"shijpost") == 0)){
            ccprintf(ss, "%-10s %c%d, %d(j%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'j', JD, disp, JS);
        }
        else if ( (strcmp(mnemonic,"ldr") == 0) || (strcmp(mnemonic,"sdr") == 0) ||
                  (strcmp(mnemonic,"ldrpost") == 0) || (strcmp(mnemonic,"sdrpost") == 0) ){
            ccprintf(ss, "%-10s %s%d, j%d(j%d)", mnemonic,
                        flags[IsFloating] ? "DR" : "j", DRD, JT, JS);
        }
        else if ( (strcmp(mnemonic,"lidr") == 0) || (strcmp(mnemonic,"sidr") == 0) ||
                  (strcmp(mnemonic,"lidrpost") == 0) || (strcmp(mnemonic,"sidrpost") == 0)){
            ccprintf(ss, "%-10s %s%d, %d(j%d)", mnemonic,
                        flags[IsFloating] ? "DR" : "j", DRD, disp, JS);
        }
        else if ( (strcmp(mnemonic,"lsvr") == 0) || (strcmp(mnemonic,"ssvr") == 0) ){
            ccprintf(ss, "%-10s %s%d, j%d(j%d)", mnemonic,
                        flags[IsFloating] ? "svr" : "svr", SVRS, JT, JS);
        }
        else if ( (strcmp(mnemonic,"lsvrpost") == 0) || (strcmp(mnemonic,"ssvrpost") == 0) ){
            ccprintf(ss, "%-10s %s%d, j%d(j%d)", mnemonic,
                        flags[IsFloating] ? "svr" : "svr", SVRS, JT, JS);
        }
        else if ( (strcmp(mnemonic,"llr") == 0) || (strcmp(mnemonic,"llrpost") == 0) 
               || (strcmp(mnemonic,"scr") == 0) || (strcmp(mnemonic,"scrpost") == 0)) {
             ccprintf(ss, "%-10s %c%d, j%d(j%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'r', RD, JT, JS);
        }
        else if ( (strcmp(mnemonic,"llj") == 0) || (strcmp(mnemonic,"lljpost") == 0) 
               || (strcmp(mnemonic,"scj") == 0) || (strcmp(mnemonic,"scjpost") == 0)) {
             ccprintf(ss, "%-10s %c%d, j%d(j%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'j', JD, JT, JS);
        }

        return ss.str();
    }

    std::string
    MemoryNoDisp::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s %c%d, r%d(r%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'r',
                        flags[IsFloating] ? FD : RD,
                        RS, RT);
    }

}};

def template LoadStoreDeclare {{
    /**
     * Static instruction class for "%(mnemonic)s".
     */
    class %(class_name)s : public %(base_class)s
    {
      public:

        /// Constructor.
        %(class_name)s(ExtMachInst machInst);

        %(BasicExecDeclare)s

        %(EACompDeclare)s

        %(InitiateAccDeclare)s

        %(CompleteAccDeclare)s
    };
}};

def template EACompDeclare {{
    Fault eaComp(%(CPU_exec_context)s *, Trace::InstRecord *) const;
}};

def template InitiateAccDeclare {{
    Fault initiateAcc(%(CPU_exec_context)s *, Trace::InstRecord *) const;
}};

def template CompleteAccDeclare {{
    Fault completeAcc(Packet *, %(CPU_exec_context)s *, Trace::InstRecord *) const;
}};

def template LoadStoreConstructor {{
    inline %(class_name)s::%(class_name)s(ExtMachInst machInst)
         : %(base_class)s("%(mnemonic)s", machInst, %(op_class)s)
    {
        %(constructor)s;
    }
}};

def template EACompExecute {{
    Fault
    %(class_name)s::eaComp(%(CPU_exec_context)s *xc,
                                   Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        if (this->isFloating()) {
            %(fp_enable_check)s;

            if(fault != NoFault)
                return fault;
        }

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        // NOTE: Trace Data is written using execute or completeAcc templates
        if (fault == NoFault) {
            xc->setEA(EA);
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def template LoadExecute {{
    Fault %(class_name)s::execute(%(CPU_exec_context)s *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        if (this->isFloating()) {
            %(fp_enable_check)s;

            if(fault != NoFault)
                return fault;
        }

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if (fault == NoFault) {
            fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};


def template LoadInitiateAcc {{
    Fault %(class_name)s::initiateAcc(%(CPU_exec_context)s *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        if (this->isFloating()) {
            %(fp_enable_check)s;

            if(fault != NoFault)
                return fault;
        }

        %(op_src_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if (fault == NoFault) {
            fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def template LoadCompleteAcc {{
    Fault %(class_name)s::completeAcc(Packet *pkt,
                                      %(CPU_exec_context)s *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        if (this->isFloating()) {
            %(fp_enable_check)s;

            if(fault != NoFault)
                return fault;
        }

        %(op_decl)s;
        %(op_rd)s;

        getMem(pkt, Mem, traceData);

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def template StoreExecute {{
    Fault %(class_name)s::execute(%(CPU_exec_context)s *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        %(fp_enable_check)s;
        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                    NULL);
        }

        if (fault == NoFault) {
            %(postacc_code)s;
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def template StoreInitiateAcc {{
    Fault %(class_name)s::initiateAcc(%(CPU_exec_context)s *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        %(fp_enable_check)s;
        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                    NULL);
        }



        return fault;
    }
}};

def template StoreCompleteAcc {{
    Fault %(class_name)s::completeAcc(Packet *pkt,
                                      %(CPU_exec_context)s *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }
}};

def format LoadMemory(memacc_code, ea_code = {{ EA = Jt + Js; }},
                     mem_flags = [], inst_flags = []) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      decode_template = ImmNopCheckDecode,
                      exec_template_base = 'Load')
}};

def format StoreMemory(memacc_code, ea_code = {{ EA = Jt + Js; }},
                     mem_flags = [], inst_flags = []) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      exec_template_base = 'Store')
}};

def format StoreMemoryImm(memacc_code, ea_code = {{ EA = Js + disp ; }},
                     mem_flags = [], inst_flags = []) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      exec_template_base = 'Store')
}};

def format LoadMemoryImm(memacc_code, ea_code = {{ EA = Js + disp ; }},
                     mem_flags = [], inst_flags = []) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      decode_template = ImmNopCheckDecode,
                      exec_template_base = 'Load')
}};

def format LoadMemorypost(memacc_code, ea_code,
                     mem_flags = [], inst_flags = []) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      decode_template = ImmNopCheckDecode,
                      exec_template_base = 'Load')
}};

def format StoreMemorypost(memacc_code, ea_code,
                     mem_flags = [], inst_flags = []) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      exec_template_base = 'Store')
}};

////////

def template SvrExecute {{
  Fault %(class_name)s::execute(%(CPU_exec_context)s *xc,
                                Trace::InstRecord *traceData) const {
    Addr EA;
    Fault fault = NoFault;

    %(op_decl)s;
    %(op_rd)s;
    %(ea_code)s;

    if (fault == NoFault) {
      %(memst_code)s;
      fault = xc->readMem(EA, (uint8_t *)Mem, 64, memAccessFlags);
      if (fault == NoFault) {
          if (traceData)
              traceData->setData(new MPUReg(Mem));
      }
      %(memld_code)s;
    }

    if (fault == NoFault) {
      %(op_wb)s;
    }

    return fault;
  }
}};


def template SvrInitiateAcc {{
  Fault %(class_name)s::initiateAcc(%(CPU_exec_context)s *xc,
                                    Trace::InstRecord *traceData) const {
    Fault fault = NoFault;

    %(op_decl)s;
    if (isStore()) %(op_rd)s;

    if (fault == NoFault) {
      %(memst_code)s;
      if (isLoad())
        fault = xc->readMem(xc->getEA(), (uint8_t *)Mem, 64, memAccessFlags);
      else if (isStore()) {
        fault = xc->writeMem((uint8_t *)Mem, 64, xc->getEA(), memAccessFlags, NULL);
        if (traceData) {
          traceData->setData(new MPUReg(Mem));
        }
      }
    }

    return fault;
  }
}};

def template SvrCompleteAcc {{
  Fault %(class_name)s::completeAcc(Packet *pkt,
                                    %(CPU_exec_context)s *xc,
                                    Trace::InstRecord *traceData) const {
    Fault fault = NoFault;
    static uint8_t Data[64];

    %(op_decl)s;
    %(op_rd)s;

    if (isLoad()) {
      memcpy(Data, pkt->getPtr<uint8_t>(), 64);
      Mem = Data;
      %(memld_code)s;
      %(op_wb)s;
    }

    return fault;
  }
}};

def template SvrEACompExecute {{
  Fault
  %(class_name)s::eaComp(%(CPU_exec_context)s *xc,
                         Trace::InstRecord *traceData) const {
    Addr EA;
    Fault fault = NoFault;

    %(op_decl)s;
    %(op_rd)s;
    %(ea_code)s;

    if (fault == NoFault) {
      xc->setEA(EA);
    }

    if (fault == NoFault) {
      %(op_wb)s;
    }
    
    return fault;
  }
}};

def format SvrLdOps(memacc_code, ea_code = {{ EA = (Jt + Js) & 0xFFFFFFC0; }}, inst_flags = []) {{
      (header_output, decoder_output, decode_block, exec_output) = \
           BiuBase(name, Name, ea_code, '', memacc_code, inst_flags, 
                   base_class = 'Memory', decode_template = ImmNopCheckDecode, exec_template_base = 'Svr')
}};

def format SvrStOps(memacc_code, ea_code = {{ EA = (Jt + Js) & 0xFFFFFFC0; }}, inst_flags = []) {{
      (header_output, decoder_output, decode_block, exec_output) = \
           BiuBase(name, Name, ea_code, memacc_code, '', inst_flags,
                   base_class = 'Memory', decode_template = ImmNopCheckDecode, exec_template_base = 'Svr')
}};

def template StoreCondExecute {{
    Fault %(class_name)s::execute(%(CPU_exec_context)s *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        uint64_t write_result = 0;

        %(fp_enable_check)s;
        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                    &write_result);
        }

        if (fault == NoFault) {
            %(postacc_code)s;
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def template StoreCondCompleteAcc {{
    Fault %(class_name)s::completeAcc(Packet *pkt,
                                      %(CPU_exec_context)s *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        %(fp_enable_check)s;
        %(op_dest_decl)s;

        uint64_t write_result = pkt->req->getExtraData();

        if (fault == NoFault) {
            %(postacc_code)s;
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def format StoreCond(memacc_code, postacc_code,
                     ea_code = {{ EA = Jt + Js; }},
                     mem_flags = [], inst_flags = []) {{
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      postacc_code, exec_template_base = 'StoreCond')
}};
